<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" dir="ltr" class="client-nojs">



<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Dependent names - cppreference.com</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">


<link rel="shortcut icon" href="../../../favicon.ico">



<link rel="stylesheet" href="../../../common/loadfe52.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/load7fe1.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>

<script src="../../../common/load404e.php"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"cpp/language/dependent_name","wgTitle":"cpp/language/dependent name","wgCurRevisionId":63962,"wgArticleId":9611,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Todo with reason"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"cpp/language/dependent_name","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-ColiruCompiler":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-js:7:ca03345b1e2c4d90a25d968753a73b92 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]-->
<script defer src="../../../../qref.js"></script></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_dependent_name skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
                <h1 id="firstHeading" class="firstHeading">Dependent names</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a>‎ | <a href="../language.html" title="cpp/language">language</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="t-navbar" style="">
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div>
<div><table class="t-nv-begin" cellpadding="0" style="line-height:1.1em;">
<tr class="t-nv"><td colspan="5"> <a href="../language.html" title="cpp/language"> Language</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../header.html" title="cpp/header"> Standard library headers</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../concept.html" title="cpp/concept"> Concepts</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html" title="cpp/utility"> Utilities library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="cpp/string"> Strings library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../container.html" title="cpp/container"> Containers library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../iterator.html" title="cpp/iterator"> Iterators library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="cpp/numeric"> Numerics library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="cpp/io"> Input/output library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="cpp/locale"> Localizations library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../atomic" title="cpp/atomic"> Atomic operations library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="cpp/thread"> Thread support library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
</table></div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../language.html" title="cpp/language"> C++ language</a><div class="t-navbar-menu"><div>
<div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h1"><td colspan="5"> General topics</td></tr>
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="../preprocessor.html" title="cpp/preprocessor"> Preprocessor</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../comment.html" title="cpp/comment"> Comments</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../keyword.html" title="cpp/keyword"> Keywords</a>
</td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="ascii.html" title="cpp/language/ascii"> ASCII chart</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="escape.html" title="cpp/language/escape"> Escape sequences</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="history.html" title="cpp/language/history"> History of C++</a>
</td></tr>
</table></div></td>
</tr>
<tr class="t-nv-h1"><td colspan="5"> Flow control</td></tr>
<tr class="t-nv-h2"><td colspan="5"> Conditional execution statements</td></tr>
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="if.html" title="cpp/language/if"> <code>if</code> statement</a>
</td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="switch.html" title="cpp/language/switch"> <code>switch</code> statement</a>
</td></tr>
</table></div></td>
</tr>
<tr class="t-nv-h2"><td colspan="5"> Iteration statements</td></tr>
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="for.html" title="cpp/language/for"> <code>for</code> loop</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="range-for.html" title="cpp/language/range-for"> range-<code>for</code> loop</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="while.html" title="cpp/language/while"> <code>while</code> loop</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="do.html" title="cpp/language/do"> <code>do-while</code> loop</a>
</td></tr>
</table></div></td>
</tr>
<tr class="t-nv-h2"><td colspan="5"> Jump statements </td></tr>
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="continue.html" title="cpp/language/continue"> <code>continue</code> statement</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="break.html" title="cpp/language/break"> <code>break</code> statement</a>
</td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="goto.html" title="cpp/language/goto"> <code>goto</code> statement</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="return.html" title="cpp/language/return"> <code>return</code> statement</a>
</td></tr>
</table></div></td>
</tr>
<tr class="t-nv-h1"><td colspan="5"> Functions</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="function.html" title="cpp/language/function"> function declaration</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="lambda.html" title="cpp/language/lambda"> lambda function declaration</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="function_template.html" title="cpp/language/function template"> function template </a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="inline.html" title="cpp/language/inline"> inline specifier</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="except_spec.html" title="cpp/language/except spec"> exception specifications</a> <span class="t-mark">(deprecated)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="noexcept_spec.html" title="cpp/language/noexcept spec"> noexcept specifier</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv-h1"><td colspan="5"> Exceptions</td></tr>
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="throw.html" title="cpp/language/throw"> throw expression</a>
</td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="try_catch.html" title="cpp/language/try catch"> try-catch block</a>
</td></tr>
</table></div></td>
</tr>
<tr class="t-nv-h1"><td colspan="5"> Namespaces</td></tr>
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="namespace.html" title="cpp/language/namespace"> namespace declaration</a>
</td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="namespace_alias.html" title="cpp/language/namespace alias"> namespace aliases</a>
</td></tr>
</table></div></td>
</tr>
<tr class="t-nv-h1"><td colspan="5"> Types</td></tr>
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="types.html" title="cpp/language/types"> fundamental types</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="class.html" title="cpp/language/class"> compound types</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="enum.html" title="cpp/language/enum"> enumeration types</a>
</td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="union.html" title="cpp/language/union"> union types</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="function.html" title="cpp/language/function"> function types</a>
</td></tr>
</table></div></td>
</tr>
<tr class="t-nv"><td colspan="5"> <a href="decltype.html" title="cpp/language/decltype"> <code>decltype</code> specifier</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv-h2"><td colspan="5"> Specifiers</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="cv.html" title="cpp/language/cv"> cv specifiers</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="storage_duration.html" title="cpp/language/storage duration"> storage duration specifiers</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="constexpr.html" title="cpp/language/constexpr"> constexpr specifier</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="auto.html" title="cpp/language/auto"> auto specifier</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="alignas.html" title="cpp/language/alignas"> alignas specifier</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv-h2"><td colspan="5"> Initialization</td></tr>
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="default_initialization.html" title="cpp/language/default initialization"> default initialization</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="value_initialization.html" title="cpp/language/value initialization"> value initialization</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="zero_initialization.html" title="cpp/language/zero initialization"> zero initialization</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="copy_initialization" title="cpp/language/copy initialization"> copy initialization</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="direct_initialization.html" title="cpp/language/direct initialization"> direct initialization</a>
</td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="aggregate_initialization.html" title="cpp/language/aggregate initialization"> aggregate initialization</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="list_initialization.html" title="cpp/language/list initialization"> list initialization</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="constant_initialization.html" title="cpp/language/constant initialization">constant initialization</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="reference_initialization.html" title="cpp/language/reference initialization">reference initialization</a>
</td></tr>
</table></div></td>
</tr>
</table></div>
</div>
<div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h2"><td colspan="5"> Literals</td></tr>
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="integer_literal.html" title="cpp/language/integer literal"> integer literals</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="character_literal.html" title="cpp/language/character literal"> character literals</a>
</td></tr> 
<tr class="t-nv"><td colspan="5"> <a href="floating_literal.html" title="cpp/language/floating literal"> floating-point literals</a>
</td></tr>  
<tr class="t-nv"><td colspan="5"> <a href="string_literal.html" title="cpp/language/string literal"> string literals</a>
</td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="bool_literal.html" title="cpp/language/bool literal"> boolean literals</a>
</td></tr>   
<tr class="t-nv"><td colspan="5"> <a href="nullptr.html" title="cpp/language/nullptr"> nullptr</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="user_literal.html" title="cpp/language/user literal"> user-defined</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
</table></div></td>
</tr>
<tr class="t-nv-h1"><td colspan="5"> Expressions</td></tr>
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="value_category.html" title="cpp/language/value category"> value categories</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="eval_order.html" title="cpp/language/eval order"> order of evaluation</a>
</td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="operators.html" title="cpp/language/operators"> operators</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="operator_precedence.html" title="cpp/language/operator precedence"> operator precedence</a>
</td></tr>
</table></div></td>
</tr>
<tr class="t-nv"><td colspan="5"> <a href="operator_alternative.html" title="cpp/language/operator alternative"> alternative representations</a>
</td></tr>
<tr class="t-nv-h1"><td colspan="5"> Utilities</td></tr>
<tr class="t-nv-h2"><td colspan="5"> Types</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="typedef.html" title="cpp/language/typedef"> <code>typedef</code> declaration</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="type_alias.html" title="cpp/language/type alias"> type alias declaration</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="attributes.html" title="cpp/language/attributes"> attributes</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv-h2"><td colspan="5"> Casts</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="implicit_cast.html" title="cpp/language/implicit cast"> implicit conversions</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="const_cast.html" title="cpp/language/const cast"> <code>const_cast</code> conversion</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="static_cast.html" title="cpp/language/static cast"> <code>static_cast</code> conversion</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="dynamic_cast.html" title="cpp/language/dynamic cast"> <code>dynamic_cast</code> conversion</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="reinterpret_cast.html" title="cpp/language/reinterpret cast"> <code>reinterpret_cast</code> conversion</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="explicit_cast.html" title="cpp/language/explicit cast"> C-style and functional cast</a>
</td></tr>
<tr class="t-nv-h2"><td colspan="5"> Memory allocation</td></tr>
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="new.html" title="cpp/language/new"> <code>new</code> expression</a>
</td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="delete.html" title="cpp/language/delete"> <code>delete</code> expression</a>
</td></tr>
</table></div></td>
</tr>
<tr class="t-nv-h1"><td colspan="5"> Classes</td></tr>
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="class.html" title="cpp/language/class"> class declaration</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="this.html" title="cpp/language/this"> <code>this</code> pointer</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="access.html" title="cpp/language/access"> access specifiers</a>
</td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="friend.html" title="cpp/language/friend"> friend specifier</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="initializer_list.html" title="cpp/language/initializer list"> initializer lists</a> </td></tr>
</table></div></td>
</tr>
<tr class="t-nv-h2"><td colspan="5"> Class-specific function properties</td></tr>
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="virtual.html" title="cpp/language/virtual"> virtual function</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="override.html" title="cpp/language/override"> override specifier</a>  <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="final.html" title="cpp/language/final"> final specifier</a>  <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="explicit.html" title="cpp/language/explicit"> explicit</a>  <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="static.html" title="cpp/language/static"> static</a> </td></tr>
</table></div></td>
</tr>
<tr class="t-nv-h2"><td colspan="5"> Special member functions</td></tr>
<tr class="t-nv-col-table">
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="default_constructor.html" title="cpp/language/default constructor"> default constructor</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="copy_constructor.html" title="cpp/language/copy constructor"> copy constructor</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="move_constructor.html" title="cpp/language/move constructor"> move constructor</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
</table></div></td>
<td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="as_operator.html" title="cpp/language/as operator"> copy assignment</a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="move_operator.html" title="cpp/language/move operator"> move assignment</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="destructor.html" title="cpp/language/destructor"> destructor</a>
</td></tr>
</table></div></td>
</tr>
<tr class="t-nv-h1"><td colspan="5">Templates </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="class_template.html" title="cpp/language/class template"> class template </a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="function_template.html" title="cpp/language/function template"> function template </a>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="template_specialization.html" title="cpp/language/template specialization"> template specialization</a>
</td></tr>   
<tr class="t-nv"><td colspan="5"> <a href="parameter_pack.html" title="cpp/language/parameter pack"> parameter packs</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv-h1"><td colspan="5"> Miscellaneous </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="asm.html" title="cpp/language/asm"> Inline assembly</a>
</td></tr>
</table></div>
</div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
</div>
<p>Inside the definition of a template (both <a href="class_template.html" title="cpp/language/class template">class template</a> and <a href="function_template.html" title="cpp/language/function template">function template</a>), the contents of some types and the values and the types of some expressions are not known until the template is instantiated, because they depend on the template parameter.
</p>
<table id="toc" class="toc"><tr><td>
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Dependent_types"><span class="tocnumber">1</span> <span class="toctext">Dependent types</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Type-dependent_expressions"><span class="tocnumber">2</span> <span class="toctext">Type-dependent expressions</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Value-dependent_expressions"><span class="tocnumber">3</span> <span class="toctext">Value-dependent expressions</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Binding_rules"><span class="tocnumber">4</span> <span class="toctext">Binding rules</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Lookup_rules"><span class="tocnumber">5</span> <span class="toctext">Lookup rules</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Current_instantiation"><span class="tocnumber">6</span> <span class="toctext">Current instantiation</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Unknown_specializations"><span class="tocnumber">7</span> <span class="toctext">Unknown specializations</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#The_typename_disambiguator_for_dependent_names"><span class="tocnumber">8</span> <span class="toctext">The <span><span><span>typename</span></span></span> disambiguator for dependent names</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#The_template_disambiguator_for_dependent_names"><span class="tocnumber">9</span> <span class="toctext">The <span><span><span>template</span></span></span> disambiguator for dependent names</span></a></li>
</ul>
</td></tr></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Dependent types">edit</a>]</span> <span class="mw-headline" id="Dependent_types">Dependent types</span>
</h3>
<p>The following types are dependent types:
</p>
<ul>
<li> template parameter
</li>
<li> a member of an <a href="dependent_name.html#Unknown_specializations" title="cpp/language/dependent name">unknown specialization</a>
</li>
<li> a nested class or enum that is a member of <a href="dependent_name.html#Unknown_specializations" title="cpp/language/dependent name">unknown specialization</a>
</li>
<li> a cv-qualified version of a dependent type
</li>
<li> a compound type constructed from a dependent type
</li>
<li> an array type constructed from a dependent type, or whose size is a value-dependent expression
</li>
<li> template instantiation whose name is a template parameter, or any of template arguments is a dependent type/expression
</li>
<li> the result of decltype() applied to a type-dependent expression
</li>
</ul>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: examples for each bullet </td>
</tr></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Type-dependent expressions">edit</a>]</span> <span class="mw-headline" id="Type-dependent_expressions">Type-dependent expressions</span>
</h3>
<p>The following expressions are type-dependent
</p>
<ul>
<li> an expression whose any subexpression is a type-dependent expression
</li>
<li> an expression that contains an identifier whose type is a dependent type
</li>
<li> an expression that contains a dependent template instantiation
</li>
<li> an expression that contains a conversion function call to a dependent type
</li>
<li> an expression that contains a nested name that refers to a member of <a href="dependent_name.html#Unknown_specializations" title="cpp/language/dependent name">unknown specialization</a>
</li>
<li> any cast expression to a dependent type
</li>
<li> new-expression that creates an object of a dependent type
</li>
<li> an expression that names a static data member of type array of unknown bound
</li>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp">this</span></span>, if the class type is a dependent type
</li>
<li> member access expression that refers to a member of <a href="dependent_name.html#Unknown_specializations" title="cpp/language/dependent name">unknown specialization</a>
</li>
<li> member access expression that refers to a member of the <a href="dependent_name.html#Current_instantiation" title="cpp/language/dependent name">current instantiation</a>, whose type is a dependent type
</li>
</ul>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr>
<td class="mbox-empty-cell"></td>
<td class="mbox-text" style="">This section is incomplete<br>Reason: examples for each bullet </td>
</tr></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Value-dependent expressions">edit</a>]</span> <span class="mw-headline" id="Value-dependent_expressions">Value-dependent expressions</span>
</h3>
<ul>
<li> an expression whose any subexpression is a value-dependent expression
</li>
<li> an expression that contains the name of a non-type template parameter
</li>
<li> an expression that contains a name declared with a dependent type
</li>
<li> a constant initialized from a value-dependent expression
</li>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp">sizeof</span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">alignof</span></span>, or <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typeid</span></span></span> of a type-dependent expression or of a dependent type
</li>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">noexcept</span></span></span> of a type-dependent expression
</li>
<li> any cast expression to a dependent type or from a value-dependent expression
</li>
<li> an expression that names a member of <a href="dependent_name.html#Unknown_specializations" title="cpp/language/dependent name">unknown specialization</a>
</li>
</ul>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Binding rules">edit</a>]</span> <span class="mw-headline" id="Binding_rules">Binding rules</span>
</h3>
<p>Non-dependent names are looked up and bound at the point of template definition. This binding holds even if at the point of template instantiation there is a better match: 
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"g(double)<span class="es1">\n</span>"</span><span class="sy4">;</span> <span class="br0">}</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> S <span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span>
        g<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// non-dependent expression, bound now</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"g(int)<span class="es1">\n</span>"</span><span class="sy4">;</span> <span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    g<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls g(int)</span>
 
    S<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> s<span class="sy4">;</span>
    s.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls g(double)</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Lookup rules">edit</a>]</span> <span class="mw-headline" id="Lookup_rules">Lookup rules</span>
</h3>
<p>Dependent names are looked up in both the declaration <i>and</i> the instantiation context. 
</p>
<p>If a function call is made that depends on a template parameter, the usual name lookup is modified as follows:
</p>
<ul>
<li> Only the function declarations visible from <i>template definition</i> are considered by unqualified/qualified (whichever applicable) name lookup
</li>
<li> Only the function declarations visible from <i>template definition</i> and from the <i>template instantiation</i> are considered by <a href="adl.html" title="cpp/language/adl">argument-dependent lookup</a>
</li>
</ul>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;string&gt;</span>
<span class="co2">#include &lt;iostream&gt;</span>
 
<span class="co1">// visible at the point of definition of f1,</span>
<span class="co1">// but not reachable by normal lookup because of X::g1</span>
<span class="kw4">void</span> g1<span class="br0">(</span><a href="../string/basic_string.html"><span class="kw1045">std::<span class="me2">string</span></span></a><span class="br0">)</span> <span class="br0">{</span> <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"::g1(string)<span class="es1">\n</span>"</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="co1">// visible at the point of definition of f2,</span>
<span class="kw4">void</span> g2<span class="br0">(</span><a href="../string/basic_string.html"><span class="kw1045">std::<span class="me2">string</span></span></a><span class="br0">)</span> <span class="br0">{</span> <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"::g2(string)<span class="es1">\n</span>"</span><span class="sy4">;</span> <span class="br0">}</span>
 
<span class="kw1">namespace</span> X <span class="br0">{</span>
  <span class="co1">// found by normal lookup from the point of definitoin</span>
  <span class="co1">// also prevents normal lookup from leaving namespace X</span>
  <span class="kw4">void</span> g1<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"X::g1(int)<span class="es1">\n</span>"</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
  <span class="co1">// point of definition of f1</span>
  <span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">class</span> T <span class="sy1">&gt;</span> <span class="kw4">void</span> f1<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span> g1<span class="br0">(</span>t<span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span>
  <span class="co1">// point of definition of f2</span>
  <span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">class</span> T <span class="sy1">&gt;</span> <span class="kw4">void</span> f2<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span> g2<span class="br0">(</span>t<span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="co1">// not visible at the point of definition</span>
<span class="kw4">void</span> g1<span class="br0">(</span><span class="kw4">char</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"::g1(char)<span class="es1">\n</span>"</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="kw4">void</span> g2<span class="br0">(</span><span class="kw4">bool</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"::g2(bool)<span class="es1">\n</span>"</span><span class="sy4">;</span> <span class="br0">}</span>
 
<span class="kw1">namespace</span> N <span class="br0">{</span>
  <span class="kw1">struct</span> Z <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
  <span class="co1">// visible only if the namespace N is examined</span>
  <span class="kw4">void</span> g1<span class="br0">(</span>Z<span class="br0">)</span> <span class="br0">{</span> <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"N::g1(Z)<span class="es1">\n</span>"</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="co1">// not visible</span>
<span class="kw4">void</span> g1<span class="br0">(</span>N<span class="sy4">::</span><span class="me2">Z</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"::g1(N::Z)'<span class="es1">\n</span>"</span><span class="sy4">;</span> <span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
 
  <span class="kw4">int</span> i<span class="sy4">;</span>
  <span class="kw4">char</span> c<span class="sy4">;</span>
  <span class="kw4">double</span> d<span class="sy4">;</span>
  <a href="../string/basic_string.html"><span class="kw1045">std::<span class="me2">string</span></span></a> s<span class="sy4">;</span>  
  N<span class="sy4">::</span><span class="me2">Z</span> z<span class="sy4">;</span>
 
  X<span class="sy4">::</span><span class="me2">f1</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// finds X::g1(int) by normal lookup from definition</span>
  X<span class="sy4">::</span><span class="me2">f1</span><span class="br0">(</span>c<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// finds X::g1(int), not ::g1(char)</span>
<span class="co1">//  X::f1(s); // error: ::f1(string) cannot be found either by</span>
              <span class="co1">// normal lookup from the point of definition,</span>
              <span class="co1">// or by ADL (which considers the std namespace in this case)</span>
  X<span class="sy4">::</span><span class="me2">f1</span><span class="br0">(</span>z<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// finds N::g1(Z) via ADL, not ::g1(Z)</span>
  X<span class="sy4">::</span><span class="me2">f2</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// finds ::g2(string) from the point of definition</span>
<span class="co1">//  X::f2(false); // error: ::g2(bool) cannot be found by normal lookup</span>
                 <span class="co1">// from the point of definitino of X::f2</span>
 
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">X::g1(int)
X::g1(int)
N::g1(Z)
::g2(string)</pre></div></div> 
</div>
<p>The purpose of this is rule is to help guard against violations of the <a href="http://en.cppreference.com/mwiki/index.php" class="new" title="cpp/language/odr (page does not exist)">one-definition-rule</a> for template instantiations.  For instance:
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// an external libary</span>
 
<span class="kw1">namespace</span> E <span class="br0">{</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
  <span class="kw4">void</span> writeObject<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> t<span class="br0">)</span> <span class="br0">{</span>
    <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"Value = "</span> <span class="sy1">&lt;&lt;</span> t <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="co1">// translation unit 1:</span>
 
<span class="co1">// Programmer 1 wants to allow E::writeObject </span>
<span class="co1">// to work with vector&lt;int&gt;</span>
 
<span class="kw1">namespace</span> P1 <span class="br0">{</span>
  <a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> os, <span class="kw4">const</span> <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy3">&amp;</span> v<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> n<span class="sy4">:</span> v<span class="br0">)</span> os <span class="sy1">&lt;&lt;</span> n<span class="sy4">;</span> <span class="kw1">return</span> os<span class="sy4">;</span>
  <span class="br0">}</span>
  <span class="kw4">void</span> doSomething<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    E<span class="sy4">::</span><span class="me2">writeObject</span><span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: will not find P1::operator&lt;&lt;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="co1">// translation unit 2:</span>
 
<span class="co1">// Programmer 2 wants to allow someExternalLibrary::writeObject </span>
<span class="co1">// to work with vector&lt; int &gt;</span>
 
<span class="kw1">namespace</span> P2 <span class="br0">{</span>
  <a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> os, <span class="kw4">const</span> <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy3">&amp;</span> v<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> n<span class="sy4">:</span> v<span class="br0">)</span> os <span class="sy1">&lt;&lt;</span> n<span class="sy4">;</span> <span class="kw1">return</span> os<span class="sy4">;</span>
  <span class="br0">}</span>
  <span class="kw4">void</span> doSomethingElse<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    E<span class="sy4">::</span><span class="me2">writeObject</span><span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: will not find P2::operator&lt;&lt;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>In the above example, were it not for the <a href="adl.html" title="cpp/language/adl">argument-dependent name lookup</a> rule, the instantiation of <span class="t-c"><span class="mw-geshi cpp source-cpp">E<span class="sy4">::</span><span class="me2">writeObject</span><span class="sy1">&lt;</span>vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;&gt;</span></span></span> would have two different definitions: one using <span class="t-c"><span class="mw-geshi cpp source-cpp">P1<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">&lt;&lt;</span></span></span> and one using <span class="t-c"><span class="mw-geshi cpp source-cpp">P2<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">&lt;&lt;</span></span></span>. On many implementations this may very well not be detected, leading to one or the other being used in both instances.
</p>
<p>To make argument-dependent lookup examine a user-defined namespace, either std::vector should be replaced by a user-defined class or its element type should be a user-defined class:
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// an external libary</span>
 
<span class="kw1">namespace</span> E <span class="br0">{</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
  <span class="kw4">void</span> writeObject<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> t<span class="br0">)</span> <span class="br0">{</span>
    <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"Value = "</span> <span class="sy1">&lt;&lt;</span> t <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="co1">// translation unit 1:</span>
 
<span class="kw1">namespace</span> P1 <span class="br0">{</span>
  <span class="co1">// user-defined type in P1 namespace</span>
  <span class="kw1">struct</span> my_int
  <span class="br0">{</span>
     <span class="kw4">int</span> m<span class="sy4">;</span>
     my_int<span class="br0">(</span><span class="br0">)</span> <span class="sy4">:</span> m<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
     my_int<span class="br0">(</span><span class="kw4">int</span> p<span class="br0">)</span> <span class="sy4">:</span> m<span class="br0">(</span>p<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
     operator <span class="kw4">int</span><span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> m<span class="sy4">;</span> <span class="br0">}</span>
  <span class="br0">}</span><span class="sy4">;</span>
  <a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> os, <span class="kw4">const</span> <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>my_int<span class="sy1">&gt;</span><span class="sy3">&amp;</span> v<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> n<span class="sy4">:</span> v<span class="br0">)</span> os <span class="sy1">&lt;&lt;</span> n<span class="sy4">;</span> <span class="kw1">return</span> os<span class="sy4">;</span>
  <span class="br0">}</span>
  <span class="kw4">void</span> doSomething<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    vector<span class="sy1">&lt;</span>my_int<span class="sy1">&gt;</span> v<span class="sy4">;</span>
    writeObject<span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: instantiates writeObject(std::vector&lt;P1::my_int&gt;)</span>
                    <span class="co1">//     which finds P1::operator&lt;&lt; via ADL</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>Note: this rule prevents code such as 
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;vector&gt;</span>
<span class="co2">#include &lt;iterator&gt;</span>
<span class="co2">#include &lt;utility&gt;</span>
 
<span class="co1">// Bad idea: operator in global namespace, but its arguments are in std::</span>
<a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> os, <a href="../utility/pair.html"><span class="kw901">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">double</span><span class="sy1">&gt;</span> p<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> os <span class="sy1">&lt;&lt;</span> p.<span class="me1">first</span> <span class="sy1">&lt;&lt;</span> <span class="st0">','</span> <span class="sy1">&lt;&lt;</span> p.<span class="me1">second</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">typedef</span> <a href="../utility/pair.html"><span class="kw901">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">double</span><span class="sy1">&gt;</span> elem_t<span class="sy4">;</span>
    <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>elem_t<span class="sy1">&gt;</span> v<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy4">;</span>
    <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> v<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// OK, ordinary lookup finds ::operator&lt;&lt;</span>
    <a href="../algorithm/copy.html"><span class="kw1276">std::<span class="me2">copy</span></span></a><span class="br0">(</span>v.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, v.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>,
              <a href="../iterator/ostream_iterator.html"><span class="kw548">std::<span class="me2">ostream_iterator</span></span></a><span class="sy1">&lt;</span>elem_t<span class="sy1">&gt;</span><span class="br0">(</span><a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a>, <span class="st0">" "</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// Error: both ordinary </span>
    <span class="co1">// lookup from the point of definition of std::ostream_iterator and ADL will </span>
    <span class="co1">// only consider the std namespace, and will find many overloads of</span>
    <span class="co1">// std::operator&lt;&lt;, so the lookup will be done. Overload resolution will then</span>
    <span class="co1">// fail to find operator&lt;&lt; for elem_t in the set found by the lookup.</span>
<span class="br0">}</span></pre></div></div>
<p><br>
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Current instantiation">edit</a>]</span> <span class="mw-headline" id="Current_instantiation"> Current instantiation </span>
</h3>
<p>Within the definition of a template class or nested class of a template class (or member function thereof), some names will be immediately bound to members of that class.
</p>
<p>In such a context, the term <i>current instantiation</i> simply refers to the instantiation of that class template with its given parameters as arguments (i.e. the class or member that is actually being defined):
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">typename</span> T1, <span class="kw1">typename</span> T2 <span class="sy1">&gt;</span> <span class="kw1">struct</span> C <span class="br0">{</span>
 
  C <span class="sy2">*</span>p1<span class="sy4">;</span>                <span class="co1">// C is the current instantiation</span>
  C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span> <span class="sy2">*</span>p2<span class="sy4">;</span>      <span class="co1">// C&lt; T1, T2 &gt; is the current instantiation</span>
  C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span> <span class="sy2">*</span>p3<span class="sy4">;</span>  <span class="co1">// C&lt; T1 *, T2 * &gt; is not the current instantiation</span>
  C<span class="sy1">&lt;</span> T2, T1 <span class="sy1">&gt;</span> <span class="sy2">*</span>p4<span class="sy4">;</span>      <span class="co1">// C&lt; T2, T1 &gt; is not the current instantiation</span>
 
  <span class="kw1">struct</span> D <span class="br0">{</span>
    D <span class="sy2">*</span>q0<span class="sy4">;</span>                  <span class="co1">// D is the current instantiation</span>
    C<span class="sy4">::</span><span class="me2">D</span> <span class="sy2">*</span>q1<span class="sy4">;</span>               <span class="co1">// C::D is the current instantiation</span>
    C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">D</span> <span class="sy2">*</span>q2<span class="sy4">;</span>     <span class="co1">// C&lt; T1, T2 &gt;::D is the current instantiation</span>
    C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">D</span> <span class="sy2">*</span>q3<span class="sy4">;</span> <span class="co1">// C&lt; T1 *, T2 * &gt;::D is not the current instantiation</span>
    C<span class="sy1">&lt;</span> T2, T1 <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">D</span> <span class="sy2">*</span>q4<span class="sy4">;</span>     <span class="co1">// C&lt; T2, T1 &gt;::D is not the current instantiation</span>
  <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">typename</span> T1, <span class="kw1">typename</span> T2 <span class="sy1">&gt;</span> <span class="kw1">struct</span> C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span> <span class="br0">{</span>
  C <span class="sy2">*</span>p1<span class="sy4">;</span>                <span class="co1">// C is the current instantiation</span>
  C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span> <span class="sy2">*</span>p2<span class="sy4">;</span>  <span class="co1">// C&lt; T1 *, T2 * &gt; is the current instantiation</span>
  C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span> <span class="sy2">*</span>p3<span class="sy4">;</span>      <span class="co1">// C&lt; T1, T2 &gt; is not the current instantiation</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p><br> 
</p>
</div>
<p>Specifically, the current instantiation is referenced within a class template by one of:
</p>
<ul>
<li> the template name [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">C</span></span> in both templates above]
</li>
<li> the template name with its formal parameters as arguments [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span></span></span> within the primary template above, <span class="t-c"><span class="mw-geshi cpp source-cpp">C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span></span></span> within the partial specialization above]
</li>
</ul>
<p>Or, within a nested class of a class template:
</p>
<ul><li> the nested class name referenced as a member of the current instantiation [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">D</span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">C<span class="sy4">::</span><span class="me2">D</span></span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">D</span></span></span> above].
</li></ul>
<p>A name used within a template class or class member, though dependent, may be understood to reference a member of the current instantiation:
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> Z <span class="br0">{</span> <span class="kw4">int</span> z<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">typename</span> T <span class="sy1">&gt;</span> <span class="kw1">struct</span> Y <span class="br0">{</span> <span class="kw4">int</span> y<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">typename</span> T <span class="sy1">&gt;</span> <span class="kw1">struct</span> A<span class="sy4">:</span> <span class="kw1">public</span> B<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span>, <span class="kw1">public</span> Z <span class="br0">{</span>
  <span class="kw4">int</span> i<span class="sy4">;</span>
  <span class="kw4">int</span> getI<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> i<span class="sy4">;</span> <span class="br0">}</span>            <span class="co1">// refers to i declared above</span>
  <span class="kw4">int</span> getI2<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> A<span class="sy4">::</span><span class="me2">i</span><span class="sy4">;</span> <span class="br0">}</span>        <span class="co1">// refers to i declared above</span>
  <span class="kw4">int</span> getI3<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">i</span><span class="sy4">;</span> <span class="br0">}</span>   <span class="co1">// refers to i declared above</span>
  <span class="kw4">int</span> getJ<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">j</span><span class="sy4">;</span> <span class="br0">}</span>    <span class="co1">// could perhaps be B&lt; T &gt;::j</span>
  <span class="kw4">int</span> getK<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> A<span class="sy1">&lt;</span> T <span class="sy2">*</span> <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">k</span><span class="sy4">;</span> <span class="br0">}</span>  <span class="co1">// could perhaps be B&lt; T &gt;::k</span>
                                            <span class="co1">//  or a member k of a </span>
                                            <span class="co1">//  partial or explicit </span>
                                            <span class="co1">//  specializaton of A</span>
  <span class="kw4">int</span> getZ<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> z<span class="sy4">;</span> <span class="br0">}</span>            <span class="co1">// refers to Z::z</span>
  <span class="kw4">int</span> getY<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> Y<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">y</span><span class="sy4">;</span> <span class="br0">}</span>    <span class="co1">// refers to Y&lt; T &gt;::y	      </span>
 
  <span class="kw4">static</span> <span class="kw4">int</span> getI<span class="br0">(</span>A <span class="sy2">*</span>a<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a<span class="sy2">-</span><span class="sy1">&gt;</span>i<span class="sy4">;</span> <span class="br0">}</span>        <span class="co1">// refers to A::i in (*a)</span>
  <span class="kw4">static</span> <span class="kw4">int</span> getJ<span class="br0">(</span>A <span class="sy2">*</span>a<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a<span class="sy2">-</span><span class="sy1">&gt;</span>j<span class="sy4">;</span> <span class="br0">}</span>        <span class="co1">// could perhaps be B&lt; T &gt;::j in (*a)</span>
  <span class="kw4">static</span> <span class="kw4">int</span> getK<span class="br0">(</span>A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span> <span class="sy2">*</span>a<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a<span class="sy2">-</span><span class="sy1">&gt;</span>k<span class="sy4">;</span> <span class="br0">}</span>   <span class="co1">// could perhaps be B&lt; T &gt;::k in (*a)</span>
                                                <span class="co1">//  or a member k of a partial or </span>
                                                <span class="co1">//  explicit specializaton of A in (*a)</span>
  <span class="kw4">static</span> <span class="kw4">int</span> getZ<span class="br0">(</span>A <span class="sy2">*</span>a<span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> a<span class="sy2">-</span><span class="sy1">&gt;</span>z<span class="sy4">;</span> <span class="br0">}</span>  <span class="co1">// refers to Z::z in (*a)	</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p><br> 
</p>
</div>
<p>A name is a <i>member of the current instantiation</i> if it is either:
</p>
<ul>
<li> an unqualified class member name [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">i</span></span> above]
</li>
<li> an unqualified member name of a non-<a href="dependent_name.html#Dependent_types" title="cpp/language/dependent name">dependent</a> base class [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">z</span></span> above]
</li>
<li> a qualified class member name, where the class name is the current instantiation [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">A<span class="sy4">::</span><span class="me2">i</span></span></span> or <span class="t-c"><span class="mw-geshi cpp source-cpp">A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">i</span></span></span> above]
</li>
<li> an object member reference, where the object type is the current instantiation [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">a<span class="sy2">-</span><span class="sy1">&gt;</span>i</span></span> above]
</li>
</ul>
<p>Note that it is implicit in these requirements that name lookup finds a declaration of the name within the scope of the class.
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Unknown specializations">edit</a>]</span> <span class="mw-headline" id="Unknown_specializations"> Unknown specializations </span>
</h3>
<p>Within a template class or function definition, lookup of a qualified name or obejct member reference may be delayed until instantiation if it is deemed to be a member of an <i>unknown specialization</i> (i.e. belonging to a template specialization whose definition is not yet known).  Such a specialization could be:
</p>
<ul>
<li> a <a href="dependent_name.html#Dependent_types" title="cpp/language/dependent name">dependent</a> base class
</li>
<li> a partial or explicit specialization of the given template
</li>
<li> a specialization of an entirely different template
</li>
</ul>
<p>Referring to the second example in the section on <a href="dependent_name.html#Current_instantiation" title="cpp/language/dependent name">Current instantiation</a>, within a class scope, a qualified name or object member reference is a <i>member of an unknown specialization</i> if the qualifying class or object type (call it <i>QT</i>) is <a href="dependent_name.html#Dependent_types" title="cpp/language/dependent name">dependent</a> and either:
</p>
<ul>
<li> <i>QT</i> is not the current instantiation [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">A<span class="sy1">&lt;</span> T <span class="sy2">*</span> <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">k</span></span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">Y<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">y</span></span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">a<span class="sy2">-</span><span class="sy1">&gt;</span>k</span></span> above]
</li>
<li> <i>QT</i> is the current instantiation, <i>but</i> does not contain a declaration of the name <i>and</i> has at least one <a href="dependent_name.html#Dependent_types" title="cpp/language/dependent name">dependent</a> base [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">j</span></span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">a<span class="sy2">-</span><span class="sy1">&gt;</span>j</span></span> above]
</li>
</ul>
<p>The latter case implies that when the qualified name or object type is the current instantiation, then either the name must be declared within the class or the class must have a <a href="dependent_name.html#Dependent_types" title="cpp/language/dependent name">dependent</a> base.
</p>
<p>[<i>Note:</i> Within a non-member function template, all such names with <a href="dependent_name.html#Dependent_types" title="cpp/language/dependent name">dependent</a> qualifying/object types are considered to be members of unknown specializations, since obviously there are no members to speak of in such a scope.]
</p>
<p>An attempt to refer to a name whose qualifier is the current instantiation, but which is neither a member of current instantiation nor a member of unknown specialization can be reported as an error immediately:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> <span class="kw1">struct</span> Base <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> Derived <span class="sy4">:</span> Base<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="co1">// unknown_type is a member of unknown specialization of Base&lt;T&gt;</span>
        <span class="co1">// lookup deferred</span>
        <span class="kw1">typename</span> Derived<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">unknown_type</span> z<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span><span class="sy1">&lt;&gt;</span> <span class="kw1">struct</span> Base<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="br0">{</span> <span class="co1">// this specialization provides it</span>
    <span class="kw1">typedef</span> <span class="kw4">int</span> unknown_type<span class="sy4">;</span> 
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> A <span class="br0">{</span>
   <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
       <span class="co1">// error_type is not a member of unknown specialization</span>
       <span class="co1">// (there is no base that could define it)</span>
       <span class="co1">// and not a member of current instantiation either</span>
       <span class="co1">// Error (may be) detected immediately</span>
       <span class="kw1">typename</span> A<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">error_type</span> y<span class="sy4">;</span>
   <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: The typename disambiguator for dependent names">edit</a>]</span> <span class="mw-headline" id="The_typename_disambiguator_for_dependent_names">The <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span></span> disambiguator for dependent names</span>
</h3>
<p>In a template definition, a name that is not a member of the current instantiation and is dependent on a template parameter is not considered to be a type unless the keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span></span> is used.
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;vector&gt;</span>
 
<span class="kw4">int</span> p <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> foo <span class="br0">(</span><span class="kw4">const</span> <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;</span>v<span class="br0">)</span>
<span class="br0">{</span>
 
    <span class="co1">// std::vector&lt;T&gt;::const_iterator is a dependent name,</span>
    <span class="kw1">typename</span> <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> it <span class="sy1">=</span> v.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="co1">// without 'typename', the following is parsed as multiplication </span>
    <span class="co1">// of the type-dependent member variable 'const_iterator' </span>
    <span class="co1">// and some variable 'p'. Since there is a global 'p' visible</span>
    <span class="co1">// at this point, this template definition compiles.</span>
    <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span><span class="sy2">*</span> p<span class="sy4">;</span> 
<span class="br0">}</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> S <span class="br0">{</span>
    <span class="kw1">typedef</span> <span class="kw4">int</span> value_t<span class="sy4">;</span> <span class="co1">// member of current instantiation</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        S<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value_t</span> n<span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>  <span class="co1">// S&lt;T&gt; is dependenent, but 'typename' not needed</span>
        <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    foo<span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// template instantiation fails: there is no member variable</span>
            <span class="co1">// called 'const_iterator' in the type std::vector&lt;int&gt;</span>
    S<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>The keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span></span> may only be used in this way before qualified names, e.g. T::x.
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: The template disambiguator for dependent names">edit</a>]</span> <span class="mw-headline" id="The_template_disambiguator_for_dependent_names">The <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span></span></span> disambiguator for dependent names</span>
</h3>
<p>Similarly, in a template definition, a dependent name that is not a member of the current instantiation is not considered to be a template name unless the disambiguation keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span></span></span> is used:
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> S <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> U<span class="sy1">&gt;</span> <span class="kw4">void</span> foo<span class="br0">(</span><span class="br0">)</span><span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> bar<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    S<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> s<span class="sy4">;</span>
    s.<span class="me1">foo</span><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: &lt; parsed as less than operator</span>
    s.<span class="kw1">template</span> foo<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>The keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span></span></span> may only be used in this way after operators <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy4">::</span></span></span> (scope resolution), <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy2">-</span><span class="sy1">&gt;</span></span></span> (member access through pointer), and <span class="t-c"><span class="mw-geshi cpp source-cpp">.</span></span> (member access), the following are all valid examples:
</p>
<ul>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="sy4">::</span><span class="kw1">template</span> foo<span class="sy1">&lt;</span>x<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span></span>
</li>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp">s.<span class="kw1">template</span> foo<span class="sy1">&lt;</span>x<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span></span>
</li>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp">this<span class="sy2">-</span><span class="sy1">&gt;</span><span class="kw1">template</span> foo<span class="sy1">&lt;</span>x<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span></span>
</li>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span> t<span class="sy4">::</span><span class="kw1">template</span> iterator<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value_type</span> v<span class="sy4">;</span></span></span>
</li>
</ul>

<!-- 
NewPP limit report
Preprocessor visited node count: 2840/1000000
Preprocessor generated node count: 7847/1000000
Post‐expand include size: 107736/2097152 bytes
Template argument size: 30768/2097152 bytes
Highest expansion depth: 17/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:9611-0!*!0!!en!*!* and timestamp 20130911061608 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="http://en.cppreference.com/mwiki/index.php">http://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&amp;oldid=63962</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks">
<a href="http://en.cppreference.com/w/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="http://en.cppreference.com/w/Category:Todo_with_reason" title="Category:Todo with reason">Todo with reason</a></li></ul>
</div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../common/loadac2a.php"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler"], null, true);
}</script>
<script src="../../../common/load345b.php"></script>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 7.270 secs. -->        
	</body>
<!-- Cached 20130911061608 -->


</html>
