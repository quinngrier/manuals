<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>std::memory_order - cppreference.com</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.18.2">
<link rel="shortcut icon" href="../../../favicon.ico">
<link rel="stylesheet" href="../../../common/load202e.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/load7fe1.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}a.new,#quickbar a.new{color:#ba0000}#toc{display:none}.editsection{display:none}

/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:4:b677bc2b5ec37947892a2d0853532528 */</style>
<script src="../../../common/load404e.php"></script><script>if(window.mw){
	mw.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "cpp/atomic/memory_order", "wgTitle": "cpp/atomic/memory order", "wgCurRevisionId": 42649, "wgArticleId": 2839, "wgIsArticle": true, "wgAction": "view", "wgUserName": null, "wgUserGroups": ["*"], "wgCategories": [], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script><script>if(window.mw){
	mw.loader.load(["mediawiki.page.startup"]);
}
</script><style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]-->
<script defer src="../../../../qref.js"></script></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_atomic_memory_order action-view skin-cppreference2 cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
                <h1 id="firstHeading" class="firstHeading">
<span style="font-size:0.7em; line-height:130%">std::</span>memory_order</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a> | <a href="../atomic.html" title="cpp/atomic">atomic</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div lang="en" dir="ltr" class="mw-content-ltr">
<div class="t-navbar" style="">
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div>
<div>
<table class="t-sb-list" cellpadding="0" style="line-height:1.1em;">
<tr><td colspan="5">  <a href="../languagehtml.html" title="cpp/language"> Language</a>
</td></tr>
<tr><td colspan="5">  <a href="../concept.html" title="cpp/concept"> Concepts</a>
</td></tr>
<tr><td colspan="5">  <a href="../utility.html" title="cpp/utility"> Utilities library</a>
</td></tr>
<tr><td colspan="5">  <a href="../string.html" title="cpp/string"> Strings library</a>
</td></tr>
<tr><td colspan="5">  <a href="../container.html" title="cpp/container"> Containers library</a>
</td></tr>
<tr><td colspan="5">  <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a>
</td></tr>
<tr><td colspan="5">  <a href="../iterator.html" title="cpp/iterator"> Iterators library</a>
</td></tr>
<tr><td colspan="5">  <a href="../numeric.html" title="cpp/numeric"> Numerics library</a>
</td></tr>
<tr><td colspan="5">  <a href="../io.html" title="cpp/io"> Input/output library</a>
</td></tr>
<tr><td colspan="5">  <a href="../locale.html" title="cpp/locale"> Localizations library</a>
</td></tr>
<tr><td colspan="5">  <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark">(C++11)</span>
</td></tr>
<tr><td colspan="5">  <a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a> <span class="t-mark">(C++11)</span>
</td></tr>
<tr><td colspan="5">  <a href="../thread.html" title="cpp/thread"> Thread support library</a> <span class="t-mark">(C++11)</span>
</td></tr>
</table>
</div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a><div class="t-navbar-menu"><div>
<div>
<table class="t-sb-list" cellpadding="0" style="">
<tr class="t-sb-list-h1"><td colspan="5">  Types
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic.html" title="cpp/atomic/atomic">atomic</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_is_lock_freehtml.html" title="cpp/atomic/atomic is lock free">atomic_is_lock_free</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr class="t-sb-list-h1"><td colspan="5">  Functions
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_store.html" title="cpp/atomic/atomic store">atomic_store<br>atomic_store_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_load.html" title="cpp/atomic/atomic load">atomic_load<br>atomic_load_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_exchange.html" title="cpp/atomic/atomic exchange">atomic_exchange<br>atomic_exchange_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_compare_exchangehtml.html" title="cpp/atomic/atomic compare exchange">atomic_compare_exchange_weak<br>atomic_compare_exchange_weak_explicit<br>atomic_compare_exchange_strong<br>atomic_compare_exchange_strong_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_add.html" title="cpp/atomic/atomic fetch add">atomic_fetch_add<br>atomic_fetch_add_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_sub.html" title="cpp/atomic/atomic fetch sub">atomic_fetch_sub<br>atomic_fetch_sub_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_and.html" title="cpp/atomic/atomic fetch and">atomic_fetch_and<br>atomic_fetch_and_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_or.html" title="cpp/atomic/atomic fetch or">atomic_fetch_or<br>atomic_fetch_or_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_xorhtml.html" title="cpp/atomic/atomic fetch xor">atomic_fetch_xor<br>atomic_fetch_xor_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr class="t-sb-list-h1"><td colspan="5">  Atomic flags
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_flag.html" title="cpp/atomic/atomic flag">atomic_flag</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_flag_test_and_set.html" title="cpp/atomic/atomic flag test and set">atomic_flag_test_and_set<br>atomic_flag_test_and_set_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_flag_clear.html" title="cpp/atomic/atomic flag clear">atomic_flag_clear<br>atomic_flag_clear_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr class="t-sb-list-h1"><td colspan="5">  Initialization
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_inithtml.html" title="cpp/atomic/atomic init">atomic_init</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="ATOMIC_VAR_INIT.html" title="cpp/atomic/ATOMIC VAR INIT">ATOMIC_VAR_INIT</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="ATOMIC_FLAG_INIT.html" title="cpp/atomic/ATOMIC FLAG INIT">ATOMIC_FLAG_INIT</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr class="t-sb-list-h1"><td colspan="5">  Memory ordering
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><strong class="selflink">memory_order</strong></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="kill_dependency.html" title="cpp/atomic/kill dependency">kill_dependency</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_thread_fence.html" title="cpp/atomic/atomic thread fence">atomic_thread_fence</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_signal_fence.html" title="cpp/atomic/atomic signal fence">atomic_signal_fence</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
</table>
</div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
</div>
<table class="t-ddcl-list">
<tr class="t-ddcl-list-header">
<td> <div>Defined in header <tt>&lt;atomic&gt;</tt>
 </div>
</td>
<td></td>
<td></td>
</tr>
<tr><td colspan="3" class="t-ddcl-list-sep"></td></tr>
<tr class="t-ddcl-list-item">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw2">enum</span> memory_order <span class="br0">{</span><br><p>    memory_order_relaxed,<br>
    memory_order_consume,<br>
    memory_order_acquire,<br>
    memory_order_release,<br>
    memory_order_acq_rel,<br>
    memory_order_seq_cst<br></p>
<span class="br0">}</span><span class="sy4">;</span></span></div>
</td>
<td class="t-ddcl-list-item-nopad">  </td>
<td> <span class="t-mark">(since C++11)</span> </td>
</tr>
<tr><td colspan="3" class="t-ddcl-list-sep"></td></tr>
</table>
<p><code>std::memory_order</code> specifies how non-atomic memory accesses are to be ordered around an atomic operation. The rationale of this is that when several threads simultaneously read and write to several variables on multi-core systems, one thread might <i>see</i> the values change in different order than another thread has written them. Also, the apparent order of changes may be different across several reader threads. Ensuring that all memory accesses to atomic variables are sequential may hurt performance in some cases. <code>std::memory_order</code> allows to specify the exact constraints that the compiler must enforce.
</p>
<p>It's possible to specify custom memory order for each atomic operation in the library via an additional parameter. The default is <span class="mw-geshi cpp source-cpp"><a href="memory_orderhtml.html"><span class="kw1664">std::<span class="me2">memory_order_seq_cst</span></span></a></span>.
</p>
<table id="toc" class="toc"><tr><td>
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1">
<a href="#Constants"><span class="tocnumber">1</span> <span class="toctext">Constants</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Relaxed_ordering"><span class="tocnumber">1.1</span> <span class="toctext">Relaxed ordering</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Release-Consume_ordering"><span class="tocnumber">1.2</span> <span class="toctext">Release-Consume ordering</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Release_sequence"><span class="tocnumber">1.3</span> <span class="toctext">Release sequence</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Release-Acquire_ordering"><span class="tocnumber">1.4</span> <span class="toctext">Release-Acquire ordering</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Sequentially-consistent_ordering"><span class="tocnumber">1.5</span> <span class="toctext">Sequentially-consistent ordering</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="#Relationship_with_volatile"><span class="tocnumber">2</span> <span class="toctext">Relationship with volatile</span></a></li>
<li class="toclevel-1 tocsection-8">
<a href="#Examples"><span class="tocnumber">3</span> <span class="toctext">Examples</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#std::memory_order_relaxed"><span class="tocnumber">3.1</span> <span class="toctext">std::memory_order_relaxed</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#std::memory_order_release_and_std::memory_order_consume"><span class="tocnumber">3.2</span> <span class="toctext">std::memory_order_release and std::memory_order_consume</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#std::memory_order_release_and_memory_order_acquire"><span class="tocnumber">3.3</span> <span class="toctext">std::memory_order_release and memory_order_acquire</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#std::memory_order_acq_rel"><span class="tocnumber">3.4</span> <span class="toctext">std::memory_order_acq_rel</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#std::memory_order_seq_cst"><span class="tocnumber">3.5</span> <span class="toctext">std::memory_order_seq_cst</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Constants">edit</a>]</span> <span class="mw-headline" id="Constants">Constants</span>
</h3>
<table class="t-dcl-list">
<tr class="t-dcl-list-header"><td colspan="2"> <div>Defined in header <code>&lt;atomic&gt;</code> </div>
</td></tr>
<tr class="t-dcl-list-sep"><td colspan="2">
</td></tr>
<tr class="t-dcl-list-hitem">
<td>  Value
</td>
<td>  Explanation
</td>
</tr>
<tr class="t-dcl-list-sep"><td colspan="2">
</td></tr>
<tr class="t-dcl-list-item">
<td>  <code>memory_order_relaxed</code>
</td>
<td>  <b>Relaxed</b> ordering: there are no constraints on reordering of memory accesses around the atomic variable.
</td>
</tr>
<tr class="t-dcl-list-sep"><td colspan="2">
</td></tr>
<tr class="t-dcl-list-item">
<td>  <code>memory_order_consume</code>
</td>
<td>  <b>Consume</b> operation: no reads in the current thread dependent on the value currently loaded can be reordered before this load. This ensures that writes to dependent variables in other threads that release the same atomic variable are visible in the current thread. On most platforms, this affects compiler optimization only.
</td>
</tr>
<tr class="t-dcl-list-sep"><td colspan="2">
</td></tr>
<tr class="t-dcl-list-item">
<td>  <code>memory_order_acquire</code>
</td>
<td>  <b>Acquire</b> operation: no reads in the current thread can be reordered before this load. This ensures that all writes in other threads that release the same atomic variable are visible in the current thread.
</td>
</tr>
<tr class="t-dcl-list-sep"><td colspan="2">
</td></tr>
<tr class="t-dcl-list-item">
<td>  <code>memory_order_release</code>
</td>
<td>  <b>Release</b> operation: no writes in the current thread can be reordered after this store. This ensures that all writes in the current thread are visible in other threads that acquire the same atomic variable.
</td>
</tr>
<tr class="t-dcl-list-sep"><td colspan="2">
</td></tr>
<tr class="t-dcl-list-item">
<td>  <code>memory_order_acq_rel</code>
</td>
<td>  <b>Acquire-release</b> operation: no reads in the current thread can be reordered before this load as well as no writes in the current thread can be reordered after this store. The operation is read-modify-write operation. It is ensured that all writes in another threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.
</td>
</tr>
<tr class="t-dcl-list-sep"><td colspan="2">
</td></tr>
<tr class="t-dcl-list-item">
<td>  <code>memory_order_seq_cst</code>
</td>
<td>  <b>Sequential ordering</b>. The operation has the same semantics as acquire-release operation, and additionally has sequentially-consistent operation ordering.
</td>
</tr>
</table>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Relaxed ordering">edit</a>]</span> <span class="mw-headline" id="Relaxed_ordering">Relaxed ordering</span>
</h4>
<p>Atomic operations tagged <span class="mw-geshi cpp source-cpp"><a href="memory_orderhtml.html"><span class="kw1659">std::<span class="me2">memory_order_relaxed</span></span></a></span> exhibit the following properties:
</p>
<ul>
<li> No ordering of other memory accesses is ensured whatsoever. This means that it is not possible to synchronize several threads using the atomic variable.
</li>
<li> Reads and writes to the atomic variable itself are ordered. Once a thread reads a value, a subsequent read by the same thread from the same object can not yield an earlier value.
</li>
</ul>
<p>For example, with <code>x</code> and <code>y</code> initially zero,
</p>
<p><span class="mw-geshi cpp source-cpp"><span class="co1">// Thread 1:</span><br>
r1 <span class="sy1">=</span> y.<span class="me1">load</span><span class="br0">(</span>memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span><br>
x.<span class="me1">store</span><span class="br0">(</span>r1, memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span><br><span class="co1">// Thread 2:</span><br>
r2 <span class="sy1">=</span> x.<span class="me1">load</span><span class="br0">(</span>memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span><br>
y.<span class="me1">store</span><span class="br0">(</span><span class="nu0">42</span>, memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span></span>
</p>
<p>is allowed to produce <code>r1 == r2 == 42</code>.
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Release-Consume ordering">edit</a>]</span> <span class="mw-headline" id="Release-Consume_ordering">Release-Consume ordering</span>
</h4>
<p>If an atomic store is tagged <span class="mw-geshi cpp source-cpp"><a href="memory_orderhtml.html"><span class="kw1662">std::<span class="me2">memory_order_release</span></span></a></span> and an atomic load from the same variable is tagged <span class="mw-geshi cpp source-cpp"><a href="memory_orderhtml.html"><span class="kw1660">std::<span class="me2">memory_order_consume</span></span></a></span>, the operations exhibit the following properties:
</p>
<ul>
<li> No writes in the writer thread can be reordered after the atomic store
</li>
<li> No reads or writes dependent on the value received from atomic load can be reordered before the atomic load. "Dependent on" means that the address or value is computed from the value of the atomic variable. This form of synchronization between threads is known as "dependency ordering".
</li>
<li> The synchronization is established only between the threads <i>releasing</i> and <i>consuming</i> the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.
</li>
<li> The synchronization is transitive. That is, if we have the following situation:
</li>
</ul>
<dl>
<dd><dl><dd><ul>
<li> Thread <i>A</i> releases atomic variable <i>a</i>.
</li>
<li> Thread <i>B</i> consumes atomic variable <i>a</i>.
</li>
<li> Atomic variable <i>b</i> is dependent on <i>a</i>.
</li>
<li> Thread <i>B</i> releases atomic variable <i>b</i>.
</li>
<li> Thread <i>C</i> consumes or acquires atomic variable <i>b</i>.
</li>
</ul></dd></dl></dd>
<dd> Then not only <i>A</i> and <i>B</i> or <i>B</i> and <i>C</i> are synchronized, but <i>A</i> and <i>C</i> also. That is, all writes by the thread <i>A</i> that were launched before the release of <i>a</i> are guaranteed to be completed once thread <i>C</i> observes the store to <i>b</i>. 
</dd>
</dl>
<p>On all mainstream CPUs, other than DEC Alpha, dependency ordering is automatic, no additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from performing speculative loads on the objects that are involved in the dependency chain)
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Release sequence">edit</a>]</span> <span class="mw-headline" id="Release_sequence">Release sequence</span>
</h4>
<p>If some atomic is store-released and several other threads perform read-modify-write operations on that atomic, a "release sequence" is formed: all threads that perform the read-modify-writes to the same atomic synchronize with the first thread and each other even if they have no <code>memory_order_release</code> semantics. This makes single producer - multiple consumers situations possible without imposing unnecessary synchronization between individual consumer threads.
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Release-Acquire ordering">edit</a>]</span> <span class="mw-headline" id="Release-Acquire_ordering">Release-Acquire ordering</span>
</h4>
<p>If an atomic store is tagged <span class="mw-geshi cpp source-cpp"><a href="memory_orderhtml.html"><span class="kw1662">std::<span class="me2">memory_order_release</span></span></a></span> and an atomic load from the same variable is tagged <span class="mw-geshi cpp source-cpp"><a href="memory_orderhtml.html"><span class="kw1661">std::<span class="me2">memory_order_acquire</span></span></a></span>, the operations exhibit the following properties:
</p>
<ul>
<li> No writes in the writer thread can be reordered after the atomic store
</li>
<li> No reads in the reader thread can be reordered before the atomic load. 
</li>
<li> The synchronization is established only between the threads <i>releasing</i> and <i>acquiring</i> the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.
</li>
<li> The synchronization is transitive. That is, if we have the following situation:
</li>
</ul>
<dl>
<dd><dl><dd><ul>
<li> Thread <i>A</i> releases atomic variable <i>a</i>.
</li>
<li> Thread <i>B</i> consumes atomic variable <i>a</i>.
</li>
<li> Thread <i>B</i> releases atomic variable <i>b</i>.
</li>
<li> Thread <i>C</i> consumes or acquires atomic variable <i>b</i>.
</li>
</ul></dd></dl></dd>
<dd> Then not only <i>A</i> and <i>B</i> or <i>B</i> and <i>C</i> are synchronized, but <i>A</i> and <i>C</i> also. That is, all writes by the thread <i>A</i> that were launched before the release of <i>a</i> are guaranteed to be completed once thread <i>C</i> observes the store to <i>b</i>. 
</dd>
</dl>
<p>On strongly-ordered systems (x86, SPARC, IBM mainframe), release-acquire ordering is automatic. No additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from moving non-atomic stores past the atomic store-relase or perform non-atomic loads earlier than the atomic load-acquire)
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Sequentially-consistent ordering">edit</a>]</span> <span class="mw-headline" id="Sequentially-consistent_ordering">Sequentially-consistent ordering</span>
</h4>
<p>If an atomic store and an is tagged <span class="mw-geshi cpp source-cpp"><a href="memory_orderhtml.html"><span class="kw1664">std::<span class="me2">memory_order_seq_cst</span></span></a></span> and an atomic load from the same variable is tagged <span class="mw-geshi cpp source-cpp"><a href="memory_orderhtml.html"><span class="kw1664">std::<span class="me2">memory_order_seq_cst</span></span></a></span>, then the operations exhibit the following properties:
</p>
<ul>
<li> No writes in the writer thread can be reordered after the atomic store
</li>
<li> No reads in the reader thread can be reordered before the atomic load.
</li>
<li> The synchronization is established between all atomic operations tagged <span class="mw-geshi cpp source-cpp"><a href="memory_orderhtml.html"><span class="kw1664">std::<span class="me2">memory_order_seq_cst</span></span></a></span>. All threads using such atomic operation see the same order of memory accesses.
</li>
</ul>
<p>Sequential ordering is necessary for many multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order. 
</p>
<p>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces all memory accesses to propagate to every thread.
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Relationship with volatile">edit</a>]</span> <span class="mw-headline" id="Relationship_with_volatile">Relationship with volatile</span>
</h3>
<p>Within a thread of execution, accesses (reads and writes) to all <span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span></span> objects are guaranteed to not be reordered relative to each other, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization. In addition, volatile accesses are not atomic (concurrent read and write is a data race) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access). One notable exception is Visual Studio, where every volatile write has release semantics and every volatile read has acquire semantics (<a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.100).aspx">MSDN</a>), and thus volatiles may be used for inter-thread synchronization. Standard <span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span></span> semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a signal handler (see also <span class="mw-geshi cpp source-cpp"><a href="atomic_signal_fence.html"><span class="kw1667">std::<span class="me2">atomic_signal_fence</span></span></a></span>)
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: Examples">edit</a>]</span> <span class="mw-headline" id="Examples">Examples</span>
</h3>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: std::memory order relaxed">edit</a>]</span> <span class="mw-headline" id="std::memory_order_relaxed"><code>std::memory_order_relaxed</code></span>
</h4>
<div class="t-example">
<p> The following example demonstrates a task (updating a global counter) that requires atomicity, but no ordering constraints since non-atomic memory is not involved.
 </p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;vector&gt;</span>
<span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
 
<a href="atomic.html"><span class="kw1632">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> cnt <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1656">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
 
<span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> n <span class="sy1">&lt;</span> <span class="nu0">1000</span><span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">)</span> <span class="br0">{</span>
        cnt.<span class="me1">fetch_add</span><span class="br0">(</span><span class="nu0">1</span>, <a href="memory_orderhtml.html"><span class="kw1659">std::<span class="me2">memory_order_relaxed</span></span></a><span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1055">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><a href="../thread/thread.html"><span class="kw1668">std::<span class="me2">thread</span></span></a><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> n <span class="sy1">&lt;</span> <span class="nu0">10</span><span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">)</span> <span class="br0">{</span>
        v.<span class="me1">emplace_back</span><span class="br0">(</span>f<span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw4">auto</span><span class="sy3">&amp;</span> t <span class="sy4">:</span> v<span class="br0">)</span> <span class="br0">{</span>
        t.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
    <a href="../io/basic_ostream.html"><span class="kw1424">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"Final counter value is "</span> <span class="sy1">&lt;&lt;</span> cnt <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">Final counter value is 10000</pre></div></div> 
</div>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: std::memory order release and std::memory order consume">edit</a>]</span> <span class="mw-headline" id="std::memory_order_release_and_std::memory_order_consume"><code>std::memory_order_release</code> and <code>std::memory_order_consume</code></span>
</h4>
<div class="t-example">
<p> This example demonstrates dependency-ordered synchronization: the integer data is not related to the pointer to string by a data-dependency relationship, thus its value is undefined in the consumer.
 </p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
 
<a href="atomic.html"><span class="kw1632">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="sy2">*</span><span class="sy1">&gt;</span> ptr<span class="sy4">;</span>
<span class="kw4">int</span> data<span class="sy4">;</span>
 
<span class="kw4">void</span> producer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p  <span class="sy1">=</span> new <a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="br0">(</span><span class="st0">"Hello"</span><span class="br0">)</span><span class="sy4">;</span>
    data <span class="sy1">=</span> <span class="nu0">42</span><span class="sy4">;</span>
    ptr.<span class="me1">store</span><span class="br0">(</span>p, <a href="memory_orderhtml.html"><span class="kw1662">std::<span class="me2">memory_order_release</span></span></a><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> consumer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p2<span class="sy4">;</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span><span class="br0">(</span>p2 <span class="sy1">=</span> ptr.<span class="me1">load</span><span class="br0">(</span><a href="memory_orderhtml.html"><span class="kw1660">std::<span class="me2">memory_order_consume</span></span></a><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span><span class="sy2">*</span>p2 <span class="sy1">==</span> <span class="st0">"Hello"</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// never fires</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span>data <span class="sy1">==</span> <span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// may or may not fire</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw1668">std::<span class="me2">thread</span></span></a> t1<span class="br0">(</span>producer<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1668">std::<span class="me2">thread</span></span></a> t2<span class="br0">(</span>consumer<span class="br0">)</span><span class="sy4">;</span>
    t1.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> t2.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br></p>
</div>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: std::memory order release and memory order acquire">edit</a>]</span> <span class="mw-headline" id="std::memory_order_release_and_memory_order_acquire"><code>std::memory_order_release</code> and <code>memory_order_acquire</code></span>
</h4>
<div class="t-example">
<p> Mutexes, concurrent queues, and other producer-consumer situations require release ordering in the publisher thread and acquire ordering in the consumer thread. This pattern establishes pairwise synchronization between threads.
 </p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
 
<a href="atomic.html"><span class="kw1632">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="sy2">*</span><span class="sy1">&gt;</span> ptr<span class="sy4">;</span>
<span class="kw4">int</span> data<span class="sy4">;</span>
 
<span class="kw4">void</span> producer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p  <span class="sy1">=</span> new <a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="br0">(</span><span class="st0">"Hello"</span><span class="br0">)</span><span class="sy4">;</span>
    data <span class="sy1">=</span> <span class="nu0">42</span><span class="sy4">;</span>
    ptr.<span class="me1">store</span><span class="br0">(</span>p, <a href="memory_orderhtml.html"><span class="kw1662">std::<span class="me2">memory_order_release</span></span></a><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> consumer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p2<span class="sy4">;</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span><span class="br0">(</span>p2 <span class="sy1">=</span> ptr.<span class="me1">load</span><span class="br0">(</span><a href="memory_orderhtml.html"><span class="kw1661">std::<span class="me2">memory_order_acquire</span></span></a><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span><span class="sy2">*</span>p2 <span class="sy1">==</span> <span class="st0">"Hello"</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// never fires</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span>data <span class="sy1">==</span> <span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// never fires</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw1668">std::<span class="me2">thread</span></span></a> t1<span class="br0">(</span>producer<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1668">std::<span class="me2">thread</span></span></a> t2<span class="br0">(</span>consumer<span class="br0">)</span><span class="sy4">;</span>
    t1.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> t2.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br></p>
</div>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: std::memory order acq rel">edit</a>]</span> <span class="mw-headline" id="std::memory_order_acq_rel"><code>std::memory_order_acq_rel</code></span>
</h4>
<div class="t-example">
<p> The follow example demonstrates transitive release-acquire ordering across three threads
 </p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
<span class="co2">#include &lt;vector&gt;</span>
 
<a href="../container/vector.html"><span class="kw1055">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> data<span class="sy4">;</span>
<a href="atomic.html"><span class="kw1632">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> flag <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1656">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
 
<span class="kw4">void</span> thread_1<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    data.<span class="me1">push_back</span><span class="br0">(</span><span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span>
    flag.<span class="me1">store</span><span class="br0">(</span><span class="nu0">1</span>, <a href="memory_orderhtml.html"><span class="kw1662">std::<span class="me2">memory_order_release</span></span></a><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> thread_2<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> expected<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>flag.<span class="me1">compare_exchange_strong</span><span class="br0">(</span>expected, <span class="nu0">2</span>, <a href="memory_orderhtml.html"><span class="kw1663">std::<span class="me2">memory_order_acq_rel</span></span></a><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        expected <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> thread_3<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">while</span> <span class="br0">(</span>flag.<span class="me1">load</span><span class="br0">(</span><a href="memory_orderhtml.html"><span class="kw1661">std::<span class="me2">memory_order_acquire</span></span></a><span class="br0">)</span> <span class="sy1">&lt;</span> <span class="nu0">2</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span>data.<span class="me1">at</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span> <span class="sy1">==</span> <span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// will never fire</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw1668">std::<span class="me2">thread</span></span></a> a<span class="br0">(</span>thread_1<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1668">std::<span class="me2">thread</span></span></a> b<span class="br0">(</span>thread_2<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1668">std::<span class="me2">thread</span></span></a> c<span class="br0">(</span>thread_3<span class="br0">)</span><span class="sy4">;</span>
    a.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> b.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> c.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br></p>
</div>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php" title="Edit section: std::memory order seq cst">edit</a>]</span> <span class="mw-headline" id="std::memory_order_seq_cst"><code>std::memory_order_seq_cst</code></span>
</h4>
<div class="t-example">
<p> This example demonstrates a situation where sequential ordering is necessary. Any other ordering may trigger the assert because it would be possible for the threads <code>c</code> and <code>d</code> to observe changes to the atomics <code>x</code> and <code>y</code> in opposite order.
 </p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
 
<a href="atomic.html"><span class="kw1632">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">bool</span><span class="sy1">&gt;</span> x <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1656">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="kw2">false</span><span class="br0">)</span><span class="sy4">;</span>
<a href="atomic.html"><span class="kw1632">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">bool</span><span class="sy1">&gt;</span> y <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1656">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="kw2">false</span><span class="br0">)</span><span class="sy4">;</span>
<a href="atomic.html"><span class="kw1632">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> z <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1656">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
 
<span class="kw4">void</span> write_x<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    x.<span class="me1">store</span><span class="br0">(</span><span class="kw2">true</span>, <a href="memory_orderhtml.html"><span class="kw1664">std::<span class="me2">memory_order_seq_cst</span></span></a><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> write_y<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    y.<span class="me1">store</span><span class="br0">(</span><span class="kw2">true</span>, <a href="memory_orderhtml.html"><span class="kw1664">std::<span class="me2">memory_order_seq_cst</span></span></a><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> read_x_then_y<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>x.<span class="me1">load</span><span class="br0">(</span><a href="memory_orderhtml.html"><span class="kw1664">std::<span class="me2">memory_order_seq_cst</span></span></a><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <span class="kw1">if</span> <span class="br0">(</span>y.<span class="me1">load</span><span class="br0">(</span><a href="memory_orderhtml.html"><span class="kw1664">std::<span class="me2">memory_order_seq_cst</span></span></a><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="sy2">++</span>z<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> read_y_then_x<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>y.<span class="me1">load</span><span class="br0">(</span><a href="memory_orderhtml.html"><span class="kw1664">std::<span class="me2">memory_order_seq_cst</span></span></a><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <span class="kw1">if</span> <span class="br0">(</span>x.<span class="me1">load</span><span class="br0">(</span><a href="memory_orderhtml.html"><span class="kw1664">std::<span class="me2">memory_order_seq_cst</span></span></a><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="sy2">++</span>z<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw1668">std::<span class="me2">thread</span></span></a> a<span class="br0">(</span>write_x<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1668">std::<span class="me2">thread</span></span></a> b<span class="br0">(</span>write_y<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1668">std::<span class="me2">thread</span></span></a> c<span class="br0">(</span>read_x_then_y<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1668">std::<span class="me2">thread</span></span></a> d<span class="br0">(</span>read_y_then_x<span class="br0">)</span><span class="sy4">;</span>
    a.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> b.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> c.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> d.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span>z.<span class="me1">load</span><span class="br0">(</span><span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// will never happen</span>
<span class="br0">}</span></pre></div></div>
<p><br></p>
</div>

<!-- 
NewPP limit report
Preprocessor node count: 2165/1000000
Post-expand include size: 61584/2097152 bytes
Template argument size: 27094/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:2839-0!*!0!!en!*!* and timestamp 20121103002443 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="http://en.cppreference.com/mwiki/index.php">http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;oldid=42649</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks catlinks-allhidden"></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script src="../../../common/loadac2a.php"></script><script>if(window.mw){
	mw.loader.load(["mediawiki.user", "mediawiki.util", "mediawiki.page.ready", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax"]);
}
</script><script src="../../../common/load345b.php"></script><script>if(window.mw){
	mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0
	,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mw.user.tokens.set({"editToken":"+\\","watchToken":false});;mw.loader.state({"user.options":"ready","user.tokens":"ready"});
	
	/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-js:4:3740695a1552aee37d594967bd36f869 */
}
</script><!-- Served in 2.849 secs. -->
</body>
<!-- Cached 20121103002443 -->
</html>
