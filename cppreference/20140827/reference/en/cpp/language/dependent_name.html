<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Dependent names - cppreference.com</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">


<link rel="shortcut icon" href="../../../favicon.ico">



<link rel="stylesheet" href="../../../common/ext.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/site_modules.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>

<script src="../../../common/startup_scripts.js"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"cpp/language/dependent_name","wgTitle":"cpp/language/dependent name","wgCurRevisionId":71717,"wgArticleId":9611,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"cpp/language/dependent_name","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-ColiruCompiler":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-js:7:ca03345b1e2c4d90a25d968753a73b92 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]-->
<script defer src="../../../../qref.js"></script></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_dependent_name skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
                <h1 id="firstHeading" class="firstHeading">Dependent names</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a>‎ | <a href="../language.1.html" title="cpp/language">language</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<div class="t-navbar" style="">
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div>
<div><table class="t-nv-begin" cellpadding="0" style="line-height:1.1em;">
<tr class="t-nv"><td colspan="5"> <a href="../language.1.html" title="cpp/language"> Language</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../header.html" title="cpp/header"> Standard library headers</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../concept.html" title="cpp/concept"> Concepts</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html" title="cpp/utility"> Utilities library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="cpp/string"> Strings library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../container.html" title="cpp/container"> Containers library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../iterator.html" title="cpp/iterator"> Iterators library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="cpp/numeric"> Numerics library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="cpp/io"> Input/output library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="cpp/locale"> Localizations library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="cpp/thread"> Thread support library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
</table></div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head"><a href="../language.1.html" title="cpp/language"> C++ language</a></div>
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="templates.html" title="cpp/language/templates"> Templates</a><div class="t-navbar-menu"><div>
<div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="template_parameters.html" title="cpp/language/template parameters"> parameters and arguments</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="class_template.html" title="cpp/language/class template"> class templates</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="function_template.html" title="cpp/language/function template"> function templates</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="member_template.html" title="cpp/language/member template"> class member templates</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="variable_template.html" title="cpp/language/variable template"> variable templates</a><span class="t-mark-rev t-since-cxx14">(C++14)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="template_argument_deduction.html" title="cpp/language/template argument deduction"> template argument deduction</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="template_specialization.html" title="cpp/language/template specialization"> explicit (full) specialization</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="partial_specialization.html" title="cpp/language/partial specialization"> partial specialization</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <strong class="selflink"> dependent names</strong> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="parameter_pack.html" title="cpp/language/parameter pack"> parameter packs</a><span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="sizeof....html" title="cpp/language/sizeof..."> sizeof...</a><span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="sfinae.html" title="cpp/language/sfinae"> SFINAE</a> </td></tr>
</table></div>
</div>
<div></div>
</div></div>
</div>
<div class="t-navbar-sep"> </div>
</div>
<p>Inside the definition of a template (both <a href="class_template.html" title="cpp/language/class template">class template</a> and <a href="function_template.html" title="cpp/language/function template">function template</a>), the contents of some types and the values and the types of some expressions are not known until the template is instantiated, because they depend on template parameters.
</p>
<table id="toc" class="toc"><tr><td>
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="dependent_name.html%23Dependent_types"><span class="tocnumber">1</span> <span class="toctext">Dependent types</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="dependent_name.html%23Type-dependent_expressions"><span class="tocnumber">2</span> <span class="toctext">Type-dependent expressions</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="dependent_name.html%23Value-dependent_expressions"><span class="tocnumber">3</span> <span class="toctext">Value-dependent expressions</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="dependent_name.html%23Binding_rules"><span class="tocnumber">4</span> <span class="toctext">Binding rules</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="dependent_name.html%23Lookup_rules"><span class="tocnumber">5</span> <span class="toctext">Lookup rules</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="dependent_name.html%23Current_instantiation"><span class="tocnumber">6</span> <span class="toctext">Current instantiation</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="dependent_name.html%23Unknown_specializations"><span class="tocnumber">7</span> <span class="toctext">Unknown specializations</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="dependent_name.html%23The_typename_disambiguator_for_dependent_names"><span class="tocnumber">8</span> <span class="toctext">The <span><span><span>typename</span></span></span> disambiguator for dependent names</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="dependent_name.html%23The_template_disambiguator_for_dependent_names"><span class="tocnumber">9</span> <span class="toctext">The <span><span><span>template</span></span></span> disambiguator for dependent names</span></a></li>
</ul>
</td></tr></table>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Dependent types">edit</a>]</span> <span class="mw-headline" id="Dependent_types">Dependent types</span>
</h3>
<p>The following types are dependent types:
</p>
<ul>
<li> template parameter
</li>
<li> a member of an <i>unknown specialization</i> (see below)
</li>
<li> a nested class/enum that is a dependent member of <i>unknown specialization</i> (see below)
</li>
<li> a cv-qualified version of a dependent type
</li>
<li> a compound type constructed from a dependent type
</li>
<li> an array type constructed from a dependent type, or whose size is a value-dependent constant expression (see below)
</li>
<li> a template-id where either the template name is a template parameter, or any of template arguments is type- or value-dependent
</li>
<li> the result of <a href="decltype.html" title="cpp/language/decltype">decltype</a> applied to a type-dependent expression
</li>
</ul>
<p>Note: a typedef member of a current instantiation is only dependent the type it refers to is.
</p>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Type-dependent expressions">edit</a>]</span> <span class="mw-headline" id="Type-dependent_expressions">Type-dependent expressions</span>
</h3>
<p>The following expressions are type-dependent
</p>
<ul>
<li> an expression whose any subexpression is a type-dependent expression
</li>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp">this</span></span>, if the class is a dependent type.
</li>
<li> an <a href="name.html" title="cpp/language/identifiers">id-expression</a> that
</li>
</ul>
<dl><dd>
<ul>
<li> contains an identifier for which name lookup finds at least one dependent declaration
</li>
<li> contains a dependent template-id
</li>
<li> contains the name of <a href="cast_operator.html" title="cpp/language/cast operator">conversion function</a> to a dependent type
</li>
<li> contains a nested name specifier or <a href="name.html" title="cpp/language/identifiers">qualified-id</a> that is a member of <i>unknown specialization</i>
</li>
<li> names a dependent member of the <i>current instantiation</i> which is a static data member of type "array of unknown bound"
</li>
</ul>
</dd></dl>
<ul>
<li> any cast expression to a dependent type
</li>
<li> <a href="new.html" title="cpp/language/new">new-expression</a> that creates an object of a dependent type
</li>
<li> member access expression that refers to a member of the <i>current instantiation</i> whose type is dependent
</li>
<li> member access expression that refers to a member of <i>unknown specialization</i>
</li>
</ul>
<p>Note: literals, pseudo-destructor calls, <a href="sizeof.html" title="cpp/language/sizeof">sizeof</a>, <a href="alignof.html" title="cpp/language/alignof">alignof</a>, <a href="typeid.html" title="cpp/language/typeid">typeid</a>, <a href="delete.html" title="cpp/language/delete">delete</a>-expressions, <a href="throw.html" title="cpp/language/throw">throw</a>-expressions, and <a href="noexcept.html" title="cpp/language/noexcept">noexcept</a>-expressions are never type-dependent because the types of these expressions cannot be.
</p>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Value-dependent expressions">edit</a>]</span> <span class="mw-headline" id="Value-dependent_expressions">Value-dependent expressions</span>
</h3>
<ul>
<li> a <a href="constant_expression.html" title="cpp/language/constant expression">constant expression</a> whose any subexpression is value-dependent
</li>
<li> an <a href="name.html" title="cpp/language/identifiers">id-expression</a> that
</li>
</ul>
<dl><dd>
<ul>
<li> is a name declared with a dependent type
</li>
<li> is a name of a non-type template parameter
</li>
<li> names a member of <i>unknown specialization</i>
</li>
</ul>
</dd></dl>
 <table class="t-rev-begin">
<tr class="t-rev t-since-cxx14">
<td>
<dl><dd>
<ul>
<li> names a static data member that is a dependent member of the <i>current instantiation</i> and is not initialized.
</li>
<li> names a static member function that is a depndent member of the <i>current instantiation</i>
</li>
</ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr>
</table>
<dl><dd>
<ul><li> is a constant with a literal type, initialized from a value-dependent expression
</li></ul>
</dd></dl>
<ul>
<li> <a href="sizeof.html" title="cpp/language/sizeof">sizeof</a>, <a href="alignof.html" title="cpp/language/alignof">alignof</a>, <a href="typeid.html" title="cpp/language/typeid">typeid</a>, <a href="noexcept.html" title="cpp/language/noexcept">noexcept</a>-expressions where the argument is a type-dependent expression or a dependent type-id
</li>
<li> any cast expression to a dependent type or from a value-dependent expression
</li>
</ul>
 <table class="t-rev-begin">
<tr class="t-rev t-since-cxx14">
<td>
<ul><li> address-of expression where the argument is <a href="name.html" title="cpp/language/identifiers">qualified-id</a> that names a dependent member of the <i>current instantiation</i>
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr>
</table>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Binding rules">edit</a>]</span> <span class="mw-headline" id="Binding_rules">Binding rules</span>
</h3>
<p>Non-dependent names are looked up and bound at the point of template definition. This binding holds even if at the point of template instantiation there is a better match: 
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"g(double)<span class="es1">\n</span>"</span><span class="sy4">;</span> <span class="br0">}</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> S <span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span>
        g<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// non-dependent expression, bound now</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"g(int)<span class="es1">\n</span>"</span><span class="sy4">;</span> <span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    g<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls g(int)</span>
 
    S<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> s<span class="sy4">;</span>
    s.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls g(double)</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Lookup rules">edit</a>]</span> <span class="mw-headline" id="Lookup_rules">Lookup rules</span>
</h3>
<p>As discussed in <a href="lookup.html" title="cpp/language/lookup">lookup</a>, the lookup of a dependent name used in a template is postponed until the template arguments are known, at which time
</p>
<ul>
<li> non-ADL lookup examines function declarations with external linkage that are visible from the <i>template definition</i> context
</li>
<li> <a href="adl.html" title="cpp/language/adl">ADL</a> examines function declarations with external linkage that are visible from both the <i>template definition</i> context and the <i>template instantiation</i> context
</li>
</ul>
<p>(in other words, adding a new function declaration after template definition does not make it visible, except via ADL).
</p>
<p>The purpose of this is rule is to help guard against violations of the <a href="http%3A//en.cppreference.com/mwiki/index.php" class="new" title="cpp/language/odr (page does not exist)">ODR</a> for template instantiations:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// an external libary</span>
<span class="kw1">namespace</span> E <span class="br0">{</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
  <span class="kw4">void</span> writeObject<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> t<span class="br0">)</span> <span class="br0">{</span>
    <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"Value = "</span> <span class="sy1">&lt;&lt;</span> t <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="co1">// translation unit 1:</span>
<span class="co1">// Programmer 1 wants to allow E::writeObject to work with vector&lt;int&gt;</span>
<span class="kw1">namespace</span> P1 <span class="br0">{</span>
  <a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> os, <span class="kw4">const</span> <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy3">&amp;</span> v<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> n<span class="sy4">:</span> v<span class="br0">)</span> os <span class="sy1">&lt;&lt;</span> n<span class="sy4">;</span> <span class="kw1">return</span> os<span class="sy4">;</span>
  <span class="br0">}</span>
  <span class="kw4">void</span> doSomething<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    E<span class="sy4">::</span><span class="me2">writeObject</span><span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: will not find P1::operator&lt;&lt;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="co1">// translation unit 2:</span>
<span class="co1">// Programmer 2 wants to allow E::writeObject to work with vector&lt;int&gt;</span>
<span class="kw1">namespace</span> P2 <span class="br0">{</span>
  <a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> os, <span class="kw4">const</span> <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy3">&amp;</span> v<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> n<span class="sy4">:</span> v<span class="br0">)</span> os <span class="sy1">&lt;&lt;</span> n<span class="sy4">;</span> <span class="kw1">return</span> os<span class="sy4">;</span>
  <span class="br0">}</span>
  <span class="kw4">void</span> doSomethingElse<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    E<span class="sy4">::</span><span class="me2">writeObject</span><span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: will not find P2::operator&lt;&lt;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>In the above example, if non-ADL lookup for operator&lt;&lt; were allowed from the instantiation context, the instantiation of <span class="t-c"><span class="mw-geshi cpp source-cpp">E<span class="sy4">::</span><span class="me2">writeObject</span><span class="sy1">&lt;</span>vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;&gt;</span></span></span> would have two different definitions: one using <span class="t-c"><span class="mw-geshi cpp source-cpp">P1<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">&lt;&lt;</span></span></span> and one using <span class="t-c"><span class="mw-geshi cpp source-cpp">P2<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">&lt;&lt;</span></span></span>. Such ODR violation may not be detected by the linker, leading to one or the other being used in both instances.
</p>
<p>To make argument-dependent lookup examine a user-defined namespace, either <code>std::vector</code> should be replaced by a user-defined class or its element type should be a user-defined class:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">namespace</span> P1 <span class="br0">{</span>
  <span class="co1">// if C is a class defined in the P1 namespace</span>
  <a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> os, <span class="kw4">const</span> <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>C<span class="sy1">&gt;</span><span class="sy3">&amp;</span> v<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">for</span><span class="br0">(</span>C n<span class="sy4">:</span> v<span class="br0">)</span> os <span class="sy1">&lt;&lt;</span> n<span class="sy4">;</span> <span class="kw1">return</span> os<span class="sy4">;</span>
  <span class="br0">}</span>
  <span class="kw4">void</span> doSomething<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>C<span class="sy1">&gt;</span> v<span class="sy4">;</span>
    E<span class="sy4">::</span><span class="me2">writeObject</span><span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: instantiates writeObject(std::vector&lt;P1::C&gt;)</span>
                       <span class="co1">//     which finds P1::operator&lt;&lt; via ADL</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Note: this rule makes it impractical to overload operators for standard library types
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;vector&gt;</span>
<span class="co2">#include &lt;iterator&gt;</span>
<span class="co2">#include &lt;utility&gt;</span>
 
<span class="co1">// Bad idea: operator in global namespace, but its arguments are in std::</span>
<a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> operator<span class="sy1">&lt;&lt;</span><span class="br0">(</span><a href="../io/basic_ostream.html"><span class="kw1414">std::<span class="me2">ostream</span></span></a><span class="sy3">&amp;</span> os, <a href="../utility/pair.html"><span class="kw901">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">double</span><span class="sy1">&gt;</span> p<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> os <span class="sy1">&lt;&lt;</span> p.<span class="me1">first</span> <span class="sy1">&lt;&lt;</span> <span class="st0">','</span> <span class="sy1">&lt;&lt;</span> p.<span class="me1">second</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">typedef</span> <a href="../utility/pair.html"><span class="kw901">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">double</span><span class="sy1">&gt;</span> elem_t<span class="sy4">;</span>
    <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>elem_t<span class="sy1">&gt;</span> v<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy4">;</span>
    <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> v<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// OK, ordinary lookup finds ::operator&lt;&lt;</span>
    <a href="../algorithm/copy.html"><span class="kw1276">std::<span class="me2">copy</span></span></a><span class="br0">(</span>v.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, v.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>,
              <a href="../iterator/ostream_iterator.html"><span class="kw548">std::<span class="me2">ostream_iterator</span></span></a><span class="sy1">&lt;</span>elem_t<span class="sy1">&gt;</span><span class="br0">(</span><a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a>, <span class="st0">" "</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// Error: both ordinary </span>
    <span class="co1">// lookup from the point of definition of std::ostream_iterator and ADL will </span>
    <span class="co1">// only consider the std namespace, and will find many overloads of</span>
    <span class="co1">// std::operator&lt;&lt;, so the lookup will be done. Overload resolution will then</span>
    <span class="co1">// fail to find operator&lt;&lt; for elem_t in the set found by the lookup.</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Current instantiation">edit</a>]</span> <span class="mw-headline" id="Current_instantiation"> Current instantiation </span>
</h3>
<p>Within the definition of a template class or nested class of a template class (or member function thereof), some names will be immediately bound to members of that class.
</p>
<p>In such a context, the term <i>current instantiation</i> simply refers to the instantiation of that class template with its given parameters as arguments (i.e. the class or member that is actually being defined):
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">typename</span> T1, <span class="kw1">typename</span> T2 <span class="sy1">&gt;</span> <span class="kw1">struct</span> C <span class="br0">{</span>
 
  C <span class="sy2">*</span>p1<span class="sy4">;</span>                <span class="co1">// C is the current instantiation</span>
  C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span> <span class="sy2">*</span>p2<span class="sy4">;</span>      <span class="co1">// C&lt; T1, T2 &gt; is the current instantiation</span>
  C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span> <span class="sy2">*</span>p3<span class="sy4">;</span>  <span class="co1">// C&lt; T1 *, T2 * &gt; is not the current instantiation</span>
  C<span class="sy1">&lt;</span> T2, T1 <span class="sy1">&gt;</span> <span class="sy2">*</span>p4<span class="sy4">;</span>      <span class="co1">// C&lt; T2, T1 &gt; is not the current instantiation</span>
 
  <span class="kw1">struct</span> D <span class="br0">{</span>
    D <span class="sy2">*</span>q0<span class="sy4">;</span>                  <span class="co1">// D is the current instantiation</span>
    C<span class="sy4">::</span><span class="me2">D</span> <span class="sy2">*</span>q1<span class="sy4">;</span>               <span class="co1">// C::D is the current instantiation</span>
    C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">D</span> <span class="sy2">*</span>q2<span class="sy4">;</span>     <span class="co1">// C&lt; T1, T2 &gt;::D is the current instantiation</span>
    C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">D</span> <span class="sy2">*</span>q3<span class="sy4">;</span> <span class="co1">// C&lt; T1 *, T2 * &gt;::D is not the current instantiation</span>
    C<span class="sy1">&lt;</span> T2, T1 <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">D</span> <span class="sy2">*</span>q4<span class="sy4">;</span>     <span class="co1">// C&lt; T2, T1 &gt;::D is not the current instantiation</span>
  <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">typename</span> T1, <span class="kw1">typename</span> T2 <span class="sy1">&gt;</span> <span class="kw1">struct</span> C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span> <span class="br0">{</span>
  C <span class="sy2">*</span>p1<span class="sy4">;</span>                <span class="co1">// C is the current instantiation</span>
  C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span> <span class="sy2">*</span>p2<span class="sy4">;</span>  <span class="co1">// C&lt; T1 *, T2 * &gt; is the current instantiation</span>
  C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span> <span class="sy2">*</span>p3<span class="sy4">;</span>      <span class="co1">// C&lt; T1, T2 &gt; is not the current instantiation</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p><br> 
</p>
</div>
<p>Specifically, the current instantiation is referenced within a class template by one of:
</p>
<ul>
<li> the template name [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">C</span></span> in both templates above]
</li>
<li> the template name with its formal parameters as arguments [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span></span></span> within the primary template above, <span class="t-c"><span class="mw-geshi cpp source-cpp">C<span class="sy1">&lt;</span> T1 <span class="sy2">*</span>, T2 <span class="sy2">*</span> <span class="sy1">&gt;</span></span></span> within the partial specialization above]
</li>
</ul>
<p>Or, within a nested class of a class template:
</p>
<ul><li> the nested class name referenced as a member of the current instantiation [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">D</span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">C<span class="sy4">::</span><span class="me2">D</span></span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">C<span class="sy1">&lt;</span> T1, T2 <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">D</span></span></span> above].
</li></ul>
<p>A name used within a template class or class member, though dependent, may be understood to reference a member of the current instantiation:
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> Z <span class="br0">{</span> <span class="kw4">int</span> z<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">typename</span> T <span class="sy1">&gt;</span> <span class="kw1">struct</span> Y <span class="br0">{</span> <span class="kw4">int</span> y<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span> <span class="kw1">typename</span> T <span class="sy1">&gt;</span> <span class="kw1">struct</span> A<span class="sy4">:</span> <span class="kw1">public</span> B<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span>, <span class="kw1">public</span> Z <span class="br0">{</span>
  <span class="kw4">int</span> i<span class="sy4">;</span>
  <span class="kw4">int</span> getI<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> i<span class="sy4">;</span> <span class="br0">}</span>            <span class="co1">// refers to i declared above</span>
  <span class="kw4">int</span> getI2<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> A<span class="sy4">::</span><span class="me2">i</span><span class="sy4">;</span> <span class="br0">}</span>        <span class="co1">// refers to i declared above</span>
  <span class="kw4">int</span> getI3<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">i</span><span class="sy4">;</span> <span class="br0">}</span>   <span class="co1">// refers to i declared above</span>
  <span class="kw4">int</span> getJ<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">j</span><span class="sy4">;</span> <span class="br0">}</span>    <span class="co1">// could perhaps be B&lt; T &gt;::j</span>
  <span class="kw4">int</span> getK<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> A<span class="sy1">&lt;</span> T <span class="sy2">*</span> <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">k</span><span class="sy4">;</span> <span class="br0">}</span>  <span class="co1">// could perhaps be B&lt; T &gt;::k</span>
                                            <span class="co1">//  or a member k of a </span>
                                            <span class="co1">//  partial or explicit </span>
                                            <span class="co1">//  specializaton of A</span>
  <span class="kw4">int</span> getZ<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> z<span class="sy4">;</span> <span class="br0">}</span>            <span class="co1">// refers to Z::z</span>
  <span class="kw4">int</span> getY<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> Y<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">y</span><span class="sy4">;</span> <span class="br0">}</span>    <span class="co1">// refers to Y&lt; T &gt;::y	      </span>
 
  <span class="kw4">static</span> <span class="kw4">int</span> getI<span class="br0">(</span>A <span class="sy2">*</span>a<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a<span class="sy2">-</span><span class="sy1">&gt;</span>i<span class="sy4">;</span> <span class="br0">}</span>        <span class="co1">// refers to A::i in (*a)</span>
  <span class="kw4">static</span> <span class="kw4">int</span> getJ<span class="br0">(</span>A <span class="sy2">*</span>a<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a<span class="sy2">-</span><span class="sy1">&gt;</span>j<span class="sy4">;</span> <span class="br0">}</span>        <span class="co1">// could perhaps be B&lt; T &gt;::j in (*a)</span>
  <span class="kw4">static</span> <span class="kw4">int</span> getK<span class="br0">(</span>A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span> <span class="sy2">*</span>a<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a<span class="sy2">-</span><span class="sy1">&gt;</span>k<span class="sy4">;</span> <span class="br0">}</span>   <span class="co1">// could perhaps be B&lt; T &gt;::k in (*a)</span>
                                                <span class="co1">//  or a member k of a partial or </span>
                                                <span class="co1">//  explicit specializaton of A in (*a)</span>
  <span class="kw4">static</span> <span class="kw4">int</span> getZ<span class="br0">(</span>A <span class="sy2">*</span>a<span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> a<span class="sy2">-</span><span class="sy1">&gt;</span>z<span class="sy4">;</span> <span class="br0">}</span>  <span class="co1">// refers to Z::z in (*a)	</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p><br> 
</p>
</div>
<p>A name is a <i>member of the current instantiation</i> if it is either:
</p>
<ul>
<li> an unqualified class member name [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">i</span></span> above]
</li>
<li> an unqualified member name of a non-<a href="dependent_name.html%23Dependent_types" title="cpp/language/dependent name">dependent</a> base class [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">z</span></span> above]
</li>
<li> a qualified class member name, where the class name is the current instantiation [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">A<span class="sy4">::</span><span class="me2">i</span></span></span> or <span class="t-c"><span class="mw-geshi cpp source-cpp">A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">i</span></span></span> above]
</li>
<li> an object member reference, where the object type is the current instantiation [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">a<span class="sy2">-</span><span class="sy1">&gt;</span>i</span></span> above]
</li>
</ul>
<p>Note that it is implicit in these requirements that name lookup finds a declaration of the name within the scope of the class.
</p>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: Unknown specializations">edit</a>]</span> <span class="mw-headline" id="Unknown_specializations"> Unknown specializations </span>
</h3>
<p>Within a template class or function definition, lookup of a qualified name or object member reference may be delayed until instantiation if it is deemed to be a member of an <i>unknown specialization</i> (i.e. belonging to a template specialization whose definition is not yet known).  Such a specialization could be:
</p>
<ul>
<li> a <a href="dependent_name.html%23Dependent_types" title="cpp/language/dependent name">dependent</a> base class
</li>
<li> a partial or explicit specialization of the given template
</li>
<li> a specialization of an entirely different template
</li>
</ul>
<p>Referring to the second example in the section on <a href="dependent_name.html%23Current_instantiation" title="cpp/language/dependent name">Current instantiation</a>, within a class scope, a qualified name or object member reference is a <i>member of an unknown specialization</i> if the qualifying class or object type (call it <i>QT</i>) is <a href="dependent_name.html%23Dependent_types" title="cpp/language/dependent name">dependent</a> and either:
</p>
<ul>
<li> <i>QT</i> is not the current instantiation [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">A<span class="sy1">&lt;</span> T <span class="sy2">*</span> <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">k</span></span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">Y<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">y</span></span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">a<span class="sy2">-</span><span class="sy1">&gt;</span>k</span></span> above]
</li>
<li> <i>QT</i> is the current instantiation, <i>but</i> does not contain a declaration of the name <i>and</i> has at least one <a href="dependent_name.html%23Dependent_types" title="cpp/language/dependent name">dependent</a> base [<i>Ex:</i> <span class="t-c"><span class="mw-geshi cpp source-cpp">A<span class="sy1">&lt;</span> T <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">j</span></span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">a<span class="sy2">-</span><span class="sy1">&gt;</span>j</span></span> above]
</li>
</ul>
<p>The latter case implies that when the qualified name or object type is the current instantiation, then either the name must be declared within the class or the class must have a <a href="dependent_name.html%23Dependent_types" title="cpp/language/dependent name">dependent</a> base.
</p>
<p>[<i>Note:</i> Within a non-member function template, all such names with <a href="dependent_name.html%23Dependent_types" title="cpp/language/dependent name">dependent</a> qualifying/object types are considered to be members of unknown specializations, since obviously there are no members to speak of in such a scope.]
</p>
<p>An attempt to refer to a name whose qualifier is the current instantiation, but which is neither a member of current instantiation nor a member of unknown specialization can be reported as an error immediately:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> <span class="kw1">struct</span> Base <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> Derived <span class="sy4">:</span> Base<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="co1">// unknown_type is a member of unknown specialization of Base&lt;T&gt;</span>
        <span class="co1">// lookup deferred</span>
        <span class="kw1">typename</span> Derived<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">unknown_type</span> z<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span><span class="sy1">&lt;&gt;</span> <span class="kw1">struct</span> Base<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> <span class="br0">{</span> <span class="co1">// this specialization provides it</span>
    <span class="kw1">typedef</span> <span class="kw4">int</span> unknown_type<span class="sy4">;</span> 
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> A <span class="br0">{</span>
   <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
       <span class="co1">// error_type is not a member of unknown specialization</span>
       <span class="co1">// (there is no base that could define it)</span>
       <span class="co1">// and not a member of current instantiation either</span>
       <span class="co1">// Error (may be) detected immediately</span>
       <span class="kw1">typename</span> A<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">error_type</span> y<span class="sy4">;</span>
   <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: The typename disambiguator for dependent names">edit</a>]</span> <span class="mw-headline" id="The_typename_disambiguator_for_dependent_names">The <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span></span> disambiguator for dependent names</span>
</h3>
<p>In a declaration or a definition of a template, including alias template, a name that is not a member of the current instantiation and is dependent on a template parameter is not considered to be a type unless the keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span></span> is used or unless it was already established as a type name, e.g. with a typedef declaration or by being used to name a base class.
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;vector&gt;</span>
 
<span class="kw4">int</span> p <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> foo <span class="br0">(</span><span class="kw4">const</span> <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;</span>v<span class="br0">)</span>
<span class="br0">{</span>
 
    <span class="co1">// std::vector&lt;T&gt;::const_iterator is a dependent name,</span>
    <span class="kw1">typename</span> <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> it <span class="sy1">=</span> v.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="co1">// without 'typename', the following is parsed as multiplication </span>
    <span class="co1">// of the type-dependent member variable 'const_iterator' </span>
    <span class="co1">// and some variable 'p'. Since there is a global 'p' visible</span>
    <span class="co1">// at this point, this template definition compiles.</span>
    <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span><span class="sy2">*</span> p<span class="sy4">;</span> 
 
    <span class="kw1">typedef</span> <span class="kw1">typename</span> <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_iterator</span> iter_t<span class="sy4">;</span>
    iter_t <span class="sy2">*</span> p2<span class="sy4">;</span> <span class="co1">// iter_t is a dependent name, but it's known to be a type name</span>
<span class="br0">}</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> S <span class="br0">{</span>
    <span class="kw1">typedef</span> <span class="kw4">int</span> value_t<span class="sy4">;</span> <span class="co1">// member of current instantiation</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        S<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value_t</span> n<span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>  <span class="co1">// S&lt;T&gt; is dependenent, but 'typename' not needed</span>
        <a href="../io/basic_ostream.html"><span class="kw1439">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1067">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    foo<span class="br0">(</span>v<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// template instantiation fails: there is no member variable</span>
            <span class="co1">// called 'const_iterator' in the type std::vector&lt;int&gt;</span>
    S<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>The keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span></span> may only be used in this way before qualified names, e.g. <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="sy4">::</span><span class="me2">x</span></span></span>.
</p>
<p>Usual qualified <a href="lookup.html" title="cpp/language/lookup">name lookup</a> is used for the identifier prefixed by <code>typename</code>, the rules do not change despite the qualifier:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A <span class="br0">{</span> <span class="co1">// A has a nested variable X and a nested type struct X</span>
   <span class="kw1">struct</span> X <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
   <span class="kw4">int</span> X<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> B <span class="br0">{</span>
    <span class="kw1">struct</span> X <span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// B has a nested type struct X</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">typename</span> T<span class="sy4">::</span><span class="me2">X</span> x<span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">void</span> foo<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    A a<span class="sy4">;</span>
    B b<span class="sy4">;</span>
    f<span class="br0">(</span>b<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: instantiates f&lt;B&gt;, T::X refers to B::X</span>
    f<span class="br0">(</span>a<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: cannot instantiate f&lt;A&gt;:</span>
          <span class="co1">// because qualified name lookup for A::X finds the data member</span>
<span class="br0">}</span></pre></div></div>
<h3>
<span class="editsection">[<a href="http%3A//en.cppreference.com/mwiki/index.php" title="Edit section: The template disambiguator for dependent names">edit</a>]</span> <span class="mw-headline" id="The_template_disambiguator_for_dependent_names">The <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span></span></span> disambiguator for dependent names</span>
</h3>
<p>Similarly, in a template definition, a dependent name that is not a member of the current instantiation is not considered to be a template name unless the disambiguation keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span></span></span> is used:
</p>
<div class="t-example">
<div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> S <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> U<span class="sy1">&gt;</span> <span class="kw4">void</span> foo<span class="br0">(</span><span class="br0">)</span><span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> bar<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    S<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> s<span class="sy4">;</span>
    s.<span class="me1">foo</span><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: &lt; parsed as less than operator</span>
    s.<span class="kw1">template</span> foo<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p>The keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span></span></span> may only be used in this way after operators <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy4">::</span></span></span> (scope resolution), <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy2">-</span><span class="sy1">&gt;</span></span></span> (member access through pointer), and <span class="t-c"><span class="mw-geshi cpp source-cpp">.</span></span> (member access), the following are all valid examples:
</p>
<ul>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="sy4">::</span><span class="kw1">template</span> foo<span class="sy1">&lt;</span>X<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span></span>
</li>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp">s.<span class="kw1">template</span> foo<span class="sy1">&lt;</span>X<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span></span>
</li>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp">this<span class="sy2">-</span><span class="sy1">&gt;</span><span class="kw1">template</span> foo<span class="sy1">&lt;</span>X<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span></span>
</li>
<li> <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span> T<span class="sy4">::</span><span class="kw1">template</span> iterator<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value_type</span> v<span class="sy4">;</span></span></span>
</li>
</ul>
<p>Due to the special rules for <a href="lookup.html" title="cpp/language/lookup">unqualified name lookup</a> for template names in member access expressions, when a template name appears in a member access expression (after <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy2">-</span><span class="sy1">&gt;</span></span></span> or after <span class="t-c"><span class="mw-geshi cpp source-cpp">.</span></span>), the disambiguator is unnecessary if there is a template with the same name found by ordinary lookup in the context of the expression. <span class="t-rev-inl t-until-cxx11"><span>However, if the template found by lookup in the context of the expression differs from the one found in the context of the class, the program is ill-formed</span> <span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span>
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;set&gt;</span>
<span class="kw1">using</span> <a href="../container/set.html"><span class="kw1071">std::<span class="me2">set</span></span></a><span class="sy4">;</span> <span class="co1">// makes 'set' visible to lookup from bar</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> 
<span class="kw1">struct</span> S <span class="br0">{</span> 
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> U<span class="sy1">&gt;</span> <span class="kw4">void</span> set<span class="br0">(</span><span class="br0">)</span><span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> bar<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    S<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> s<span class="sy4">;</span>
    s.<span class="me1">set</span><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// not an error if ::set is visible:</span>
                <span class="co1">// (and since C++11, this is well-formed)</span>
    s.<span class="kw1">template</span> set<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// works with and without ::set</span>
<span class="br0">}</span></pre></div></div>

<!-- 
NewPP limit report
Preprocessor visited node count: 2039/1000000
Preprocessor generated node count: 3934/1000000
Post‐expand include size: 33057/2097152 bytes
Template argument size: 21299/2097152 bytes
Highest expansion depth: 13/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:9611-0!*!0!!en!*!* and timestamp 20140819141244 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="http%3A//en.cppreference.com/mwiki/index.php">http://en.cppreference.com/mwiki/index.php?title=cpp/language/dependent_name&amp;oldid=71717</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks catlinks-allhidden"></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../common/skin_scripts.js"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler"], null, true);
}</script>
<script src="../../../common/site_scripts.js"></script>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 6.249 secs. -->
	</body>
<!-- Cached 20140819141244 -->
</html>
