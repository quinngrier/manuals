<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" dir="ltr" class="client-nojs">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>std::memory_order - cppreference.com</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.18.2">
<link rel="shortcut icon" href="../../../favicon.ico">
<link rel="stylesheet" href="../../../common/load202e.css?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cskins.cppreference2&amp;only=styles&amp;skin=cppreference2&amp;*">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/load7fe1.css?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=cppreference2&amp;*">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}a.new,#quickbar a.new{color:#ba0000}#toc{display:none}.editsection{display:none}

/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:4:b677bc2b5ec37947892a2d0853532528 */</style>
<script src="../../../common/load404e.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=cppreference2&amp;*"></script><script>if(window.mw){
	mw.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "cpp/atomic/memory_order", "wgTitle": "cpp/atomic/memory order", "wgCurRevisionId": 33527, "wgArticleId": 2839, "wgIsArticle": true, "wgAction": "view", "wgUserName": null, "wgUserGroups": ["*"], "wgCategories": [], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script><script>if(window.mw){
	mw.loader.load(["mediawiki.page.startup"]);
}
</script><style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]-->
<script defer src="../../../../qref.js"></script></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_atomic_memory_order action-view skin-cppreference2 cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
                <h1 id="firstHeading" class="firstHeading">
<span style="font-size:0.7em; line-height:130%">std::</span>memory_order</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a> | <a href="../atomic.html" title="cpp/atomic">atomic</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div lang="en" dir="ltr" class="mw-content-ltr">
<div class="t-navbar" style="">
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div><div>
<table class="t-sb-list-begin" cellpadding="0" style="line-height:1.1em;">
<tr><td colspan="5">  <a href="../language.html" title="cpp/language"> Language</a>
</td></tr>
<tr><td colspan="5">  <a href="../concept.html" title="cpp/concept"> Concepts</a>
</td></tr>
<tr><td colspan="5">  <a href="../utility.html" title="cpp/utility"> Utilities library</a>
</td></tr>
<tr><td colspan="5">  <a href="../string.html" title="cpp/string"> Strings library</a>
</td></tr>
<tr><td colspan="5">  <a href="../container.html" title="cpp/container"> Containers library</a>
</td></tr>
<tr><td colspan="5">  <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a>
</td></tr>
<tr><td colspan="5">  <a href="../iteratorhtml.html" title="cpp/iterator"> Iterators library</a>
</td></tr>
<tr><td colspan="5">  <a href="../numeric.html" title="cpp/numeric"> Numerics library</a>
</td></tr>
<tr><td colspan="5">  <a href="../io.html" title="cpp/io"> Input/output library</a>
</td></tr>
<tr><td colspan="5">  <a href="../locale.html" title="cpp/locale"> Localizations library</a>
</td></tr>
<tr><td colspan="5">  <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark">(C++11)</span>
</td></tr>
<tr><td colspan="5">  <a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a> <span class="t-mark">(C++11)</span>
</td></tr>
<tr><td colspan="5">  <a href="../thread.html" title="cpp/thread"> Thread support library</a> <span class="t-mark">(C++11)</span>
</td></tr>
</table>
</div></div></div>
</div>
<div class="t-navbar-sep"> </div>
<div class="t-navbar-head">
<a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a><div class="t-navbar-menu"><div><div>
<table class="t-sb-list-begin" cellpadding="0" style="">
<tr class="t-sb-list-h1"><td colspan="5">  Types
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic.html" title="cpp/atomic/atomic">atomic</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_is_lock_free.html" title="cpp/atomic/atomic is lock free">atomic_is_lock_free</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr class="t-sb-list-h1"><td colspan="5">  Functions
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_storehtml.html" title="cpp/atomic/atomic store">atomic_store<br>atomic_store_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_load.html" title="cpp/atomic/atomic load">atomic_load<br>atomic_load_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_exchange.html" title="cpp/atomic/atomic exchange">atomic_exchange<br>atomic_exchange_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_compare_exchange.html" title="cpp/atomic/atomic compare exchange">atomic_compare_exchange_weak<br>atomic_compare_exchange_weak_explicit<br>atomic_compare_exchange_strong<br>atomic_compare_exchange_strong_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_addhtml.html" title="cpp/atomic/atomic fetch add">atomic_fetch_add<br>atomic_fetch_add_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_sub.html" title="cpp/atomic/atomic fetch sub">atomic_fetch_sub<br>atomic_fetch_sub_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_and.html" title="cpp/atomic/atomic fetch and">atomic_fetch_and<br>atomic_fetch_and_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_or.html" title="cpp/atomic/atomic fetch or">atomic_fetch_or<br>atomic_fetch_or_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_fetch_xorhtml.html" title="cpp/atomic/atomic fetch xor">atomic_fetch_xor<br>atomic_fetch_xor_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr class="t-sb-list-h1"><td colspan="5">  Atomic flags
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_flag.html" title="cpp/atomic/atomic flag">atomic_flag</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_flag_test_and_set.html" title="cpp/atomic/atomic flag test and set">atomic_flag_test_and_set<br>atomic_flag_test_and_set_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_flag_clearhtml.html" title="cpp/atomic/atomic flag clear">atomic_flag_clear<br>atomic_flag_clear_explicit</a></td>
<td>
<span class="t-mark">(C++11)</span><br><span class="t-mark">(C++11)</span>
</td>
</tr></table>
</td></tr>
<tr class="t-sb-list-h1"><td colspan="5">  Initialization
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/atomic_init&amp;action=edit&amp;redlink=1" class="new" title="cpp/atomic/atomic init (page does not exist)">atomic_init</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/ATOMIC_VAR_INIT&amp;action=edit&amp;redlink=1" class="new" title="cpp/atomic/ATOMIC VAR INIT (page does not exist)">ATOMIC_VAR_INIT</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="ATOMIC_FLAG_INIT.html" title="cpp/atomic/ATOMIC FLAG INIT">ATOMIC_FLAG_INIT</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr class="t-sb-list-h1"><td colspan="5">  Memory ordering
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><strong class="selflink">memory_order</strong></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="kill_dependencyhtml.html" title="cpp/atomic/kill dependency">kill_dependency</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_thread_fence.html" title="cpp/atomic/atomic thread fence">atomic_thread_fence</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
<tr><td colspan="5"> <table class="t-sb-list-ln-table"><tr>
<td><a href="atomic_signal_fence.html" title="cpp/atomic/atomic signal fence">atomic_signal_fence</a></td>
<td><span class="t-mark">(C++11)</span></td>
</tr></table>
</td></tr>
</table>
</div></div></div>
</div>
<div class="t-navbar-sep"> </div>
</div>
<table class="t-ddcl-list-begin">
<tr class="t-ddcl-list-header">
<td> <div>Defined in header <tt>&lt;atomic&gt;</tt>
 </div>
</td>
<td></td>
<td></td>
</tr>
<tr><td colspan="3" class="t-ddcl-list-sep"></td></tr>
<tr class="t-ddcl-list-item">
<td class="t-ddcl-list-item-nopad"> <div><span class="mw-geshi cpp source-cpp"><span class="kw2">enum</span> memory_order <span class="br0">{</span><br><p>    memory_order_relaxed,<br>
    memory_order_consume,<br>
    memory_order_acquire,<br>
    memory_order_release,<br>
    memory_order_acq_rel,<br>
    memory_order_seq_cst<br></p>
<span class="br0">}</span> memory_order<span class="sy4">;</span></span></div>
</td>
<td class="t-ddcl-list-item-nopad">  </td>
<td class="t-ddcl-list-item-nopad">  </td>
</tr>
<tr><td colspan="3" class="t-ddcl-list-sep"></td></tr>
</table>
<p>On multicore systems, when a thread writes a value to memory, it becomes immediately available for reading on the same core, but threads executing on other cores may see the previous value for some time, and when they get to see values change, it may not be in the same order as what other threads see. In addition, both C++ compilers and CPUs may reorder regular memory accesses within a single thread for efficiency.
</p>
<p>Each atomic operation accepts a <span class="mw-geshi cpp source-cpp"><a href="memory_order.html"><span class="kw1652">std::<span class="me2">memory_order</span></span></a></span> as an additional parameter, which specifies how non-atomic memory accesses are to be ordered around this atomic operation.
</p>
<table id="toc" class="toc"><tr><td>
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1">
<a href="#Constants"><span class="tocnumber">1</span> <span class="toctext">Constants</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Sequentially-consistent_ordering"><span class="tocnumber">1.1</span> <span class="toctext">Sequentially-consistent ordering</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Release-Acquire_ordering"><span class="tocnumber">1.2</span> <span class="toctext">Release-Acquire ordering</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Release-Consume_ordering"><span class="tocnumber">1.3</span> <span class="toctext">Release-Consume ordering</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Release_sequence"><span class="tocnumber">1.4</span> <span class="toctext">Release sequence</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Relaxed_ordering"><span class="tocnumber">1.5</span> <span class="toctext">Relaxed ordering</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7">
<a href="#Examples"><span class="tocnumber">2</span> <span class="toctext">Examples</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#std::memory_order_seq_cst"><span class="tocnumber">2.1</span> <span class="toctext">std::memory_order_seq_cst</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#std::memory_order_relaxed"><span class="tocnumber">2.2</span> <span class="toctext">std::memory_order_relaxed</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#std::memory_order_release_and_memory_order_acquire"><span class="tocnumber">2.3</span> <span class="toctext">std::memory_order_release and memory_order_acquire</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#std::memory_order_ack_rel"><span class="tocnumber">2.4</span> <span class="toctext">std::memory_order_ack_rel</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#std::memory_order_release_and_std::memory_order_consume"><span class="tocnumber">2.5</span> <span class="toctext">std::memory_order_release and std::memory_order_consume</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=1" title="Edit section: Constants">edit</a>]</span> <span class="mw-headline" id="Constants">Constants</span>
</h3>
<table class="t-dcl-list-begin">
<tr class="t-dcl-list-header"><td colspan="2"> <div>Defined in header <tt>&lt;atomic&gt;</tt> </div>
</td></tr>
<tr><td colspan="2" class="t-dcl-list-sep">
</td></tr>
<tr class="t-dcl-list-hitem">
<td>  Value
</td>
<td>  Meaning
</td>
</tr>
<tr><td colspan="2" class="t-dcl-list-sep">
</td></tr>
<tr class="t-dcl-list-item">
<td>  <tt>memory_order_relaxed</tt>
</td>
<td>  The operation does not order memory.
</td>
</tr>
<tr><td colspan="2" class="t-dcl-list-sep">
</td></tr>
<tr class="t-dcl-list-item">
<td>  <tt>memory_order_consume</tt>
</td>
<td>  Performs a consume operation on the affected memory location, marking the root of a data dependency tree. The reads from the affected memory location that carry data dependency cannot be reordered before the load; other reads can be. On most platforms, this affects compiler optimization only.
</td>
</tr>
<tr><td colspan="2" class="t-dcl-list-sep">
</td></tr>
<tr class="t-dcl-list-item">
<td>  <tt>memory_order_acquire</tt>
</td>
<td>  Performs an acquire operation on the affected memory locations, thus making regular memory writes in other threads released through the atomic variable to which it is applied, visible to the current thread. No reads from the affected memory location can be reordered before the load.
</td>
</tr>
<tr><td colspan="2" class="t-dcl-list-sep">
</td></tr>
<tr class="t-dcl-list-item">
<td>  <tt>memory_order_release</tt>
</td>
<td>  Performs a release operation on the affected memory locations, thus making regular memory writes visible to other threads through the atomic variable to which it is applied.
</td>
</tr>
<tr><td colspan="2" class="t-dcl-list-sep">
</td></tr>
<tr class="t-dcl-list-item">
<td>  <tt>memory_order_acq_rel</tt>
</td>
<td>  The operation has both acquire and release semantics.
</td>
</tr>
<tr><td colspan="2" class="t-dcl-list-sep">
</td></tr>
<tr class="t-dcl-list-item">
<td>  <tt>memory_order_seq_cst</tt>
</td>
<td>  The operation has both acquire and release semantics, and in addition, has sequentially-consistent operation ordering.
</td>
</tr>
</table>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=2" title="Edit section: Sequentially-consistent ordering">edit</a>]</span> <span class="mw-headline" id="Sequentially-consistent_ordering">Sequentially-consistent ordering</span>
</h4>
<p>The default is <span class="mw-geshi cpp source-cpp"><a href="memory_order.html"><span class="kw1658">std::<span class="me2">memory_order_seq_cst</span></span></a></span> which establishes a single total ordering over all atomic operations tagged with this tag: all threads see the same order of such atomic operations and no memory_order_seq_cst atomic operations can be reordered. Sequential ordering is necessary for many multiple producer-multiple consumer situation where all consumers must observe the actions of all producers occurring in the same order. 
</p>
<p>On all multicore systems, total sequential ordering requires a full memory fence CPU instruction which may become a performance bottleneck since it forces all memory accesses to propagate to every thread.
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=3" title="Edit section: Release-Acquire ordering">edit</a>]</span> <span class="mw-headline" id="Release-Acquire_ordering">Release-Acquire ordering</span>
</h4>
<p>If an atomic store is tagged <span class="mw-geshi cpp source-cpp"><a href="memory_order.html"><span class="kw1656">std::<span class="me2">memory_order_release</span></span></a></span> and an atomic load from the same variable is tagged <span class="mw-geshi cpp source-cpp"><a href="memory_order.html"><span class="kw1655">std::<span class="me2">memory_order_acquire</span></span></a></span>, pairwise synchronization is established between the thread that does the release and the thread that does the acquire. Different threads can see different ordering, but the thread that does the release will observe exactly the same order of atomic operations as the thread that does the acquire on these atomic variables. Moreover, any non-atomic and relaxed atomic stores that happen before the release in the first thread will be guaranteed to be completed from the point of view of the second thread before it does the acquire.
</p>
<p>Release-acquire synchronization is transitive: if after the load-acquire, the second thread does a store-release on some other atomic, which the third thread load-acquires, non-atomic and relaxed events that happened in the first thread are now guaranteed to be visible to the third thread. The second thread in this case may use the tag std::memory_order_acq_rel (see example).
</p>
<p>On strongly-ordered systems (x86, SPARC, IBM mainframe), release-acquire ordering is automatic. No additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from moving non-atomic stores past the atomic store-relase or perform non-atomic loads earlier than the atomic load-acquire)
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=4" title="Edit section: Release-Consume ordering">edit</a>]</span> <span class="mw-headline" id="Release-Consume_ordering">Release-Consume ordering</span>
</h4>
<p>If an atomic store is tagged <span class="mw-geshi cpp source-cpp"><a href="memory_order.html"><span class="kw1656">std::<span class="me2">memory_order_release</span></span></a></span> and an atomic load from the same variable is tagged <span class="mw-geshi cpp source-cpp"><a href="memory_order.html"><span class="kw1654">std::<span class="me2">memory_order_consume</span></span></a></span>, a weaker form of synchronization is established, known as "dependency ordering". Only the non-atomic and relaxed atomic operations that carry a data dependency to and from the atomic that participates in the store-release and load-consume link are sequenced, all other operations within each thread may be reordered freely (see example). Like the synchronizes-with relationship established by release and acquire, the dependency-ordered-before relationship established by release and consume can propagate through multiple threads.
</p>
<p>On all mainstream CPUs, other than DEC Alpha, dependency ordering is automatic, no additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from performing speculative loads on the objects that are involved in the dependency chain)
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=5" title="Edit section: Release sequence">edit</a>]</span> <span class="mw-headline" id="Release_sequence">Release sequence</span>
</h4>
<p>If some atomic is store-released and several other threads perform read-modify-write operations on that atomic, a "release sequence" is formed: all threads that perform the read-modify-writes to the same atomic synchronize with the first thread and each other even if they have no memory_order_release semantics. This makes single producer - multiple consumers situations possible without imposing unnecessary synchronization between individual consumer threads.
</p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=6" title="Edit section: Relaxed ordering">edit</a>]</span> <span class="mw-headline" id="Relaxed_ordering">Relaxed ordering</span>
</h4>
<p>Atomic operations tagged <span class="mw-geshi cpp source-cpp"><a href="memory_order.html"><span class="kw1653">std::<span class="me2">memory_order_relaxed</span></span></a></span> do not participate in any synchronization and do not impose any ordering except that once a thread reads a value, a subsequent read from the same thread from the same object cannot read an earlier value. For example, with x and y initially zero,
</p>
<p><span class="mw-geshi cpp source-cpp"><span class="co1">// Thread 1:</span><br>
    r1 <span class="sy1">=</span> y.<span class="me1">load</span><span class="br0">(</span>memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span><br>
    x.<span class="me1">store</span><span class="br0">(</span>r1, memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span><br>
    <span class="co1">// Thread 2:</span><br>
    r2 <span class="sy1">=</span> x.<span class="me1">load</span><span class="br0">(</span>memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span><br>
    y.<span class="me1">store</span><span class="br0">(</span><span class="nu0">42</span>, memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span></span>
</p>
<p>Is allowed to produce r1 == r2 == 42
</p>
<h3>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=7" title="Edit section: Examples">edit</a>]</span> <span class="mw-headline" id="Examples">Examples</span>
</h3>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=8" title="Edit section: std::memory order seq cst">edit</a>]</span> <span class="mw-headline" id="std::memory_order_seq_cst">std::memory_order_seq_cst</span>
</h4>
<p> This example demonstrates a situation where sequential ordering is necessary. Any other ordering may trigger the assert because it would be possible for the threads c and d to observe changes to the atomics x and y in opposite order.
 </p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
 
<a href="atomic.html"><span class="kw1626">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">bool</span><span class="sy1">&gt;</span> x <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1650">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="kw2">false</span><span class="br0">)</span><span class="sy4">;</span>
<a href="atomic.html"><span class="kw1626">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">bool</span><span class="sy1">&gt;</span> y <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1650">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="kw2">false</span><span class="br0">)</span><span class="sy4">;</span>
<a href="atomic.html"><span class="kw1626">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> z <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1650">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
 
<span class="kw4">void</span> write_x<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    x.<span class="me1">store</span><span class="br0">(</span><span class="kw2">true</span>, <a href="memory_order.html"><span class="kw1658">std::<span class="me2">memory_order_seq_cst</span></span></a><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> write_y<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    y.<span class="me1">store</span><span class="br0">(</span><span class="kw2">true</span>, <a href="memory_order.html"><span class="kw1658">std::<span class="me2">memory_order_seq_cst</span></span></a><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> read_x_then_y<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>x.<span class="me1">load</span><span class="br0">(</span><a href="memory_order.html"><span class="kw1658">std::<span class="me2">memory_order_seq_cst</span></span></a><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <span class="kw1">if</span> <span class="br0">(</span>y.<span class="me1">load</span><span class="br0">(</span><a href="memory_order.html"><span class="kw1658">std::<span class="me2">memory_order_seq_cst</span></span></a><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="sy2">++</span>z<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> read_y_then_x<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>y.<span class="me1">load</span><span class="br0">(</span><a href="memory_order.html"><span class="kw1658">std::<span class="me2">memory_order_seq_cst</span></span></a><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <span class="kw1">if</span> <span class="br0">(</span>x.<span class="me1">load</span><span class="br0">(</span><a href="memory_order.html"><span class="kw1658">std::<span class="me2">memory_order_seq_cst</span></span></a><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="sy2">++</span>z<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw1662">std::<span class="me2">thread</span></span></a> a<span class="br0">(</span>write_x<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1662">std::<span class="me2">thread</span></span></a> b<span class="br0">(</span>write_y<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1662">std::<span class="me2">thread</span></span></a> c<span class="br0">(</span>read_x_then_y<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1662">std::<span class="me2">thread</span></span></a> d<span class="br0">(</span>read_y_then_x<span class="br0">)</span><span class="sy4">;</span>
    a.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> b.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> c.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> d.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span>z.<span class="me1">load</span><span class="br0">(</span><span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// will never happen</span>
<span class="br0">}</span></pre></div></div>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=9" title="Edit section: std::memory order relaxed">edit</a>]</span> <span class="mw-headline" id="std::memory_order_relaxed">std::memory_order_relaxed</span>
</h4>
<p> The following example demonstrates a task (updating a global counter) that requires atomicity, but no ordering constraints since non-atomic memory is not involved.
 </p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;vector&gt;</span>
<span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
 
<a href="atomic.html"><span class="kw1626">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> cnt <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1650">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
 
<span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> n <span class="sy1">&lt;</span> <span class="nu0">1000</span><span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">)</span> <span class="br0">{</span>
        cnt.<span class="me1">fetch_add</span><span class="br0">(</span><span class="nu0">1</span>, <a href="memory_order.html"><span class="kw1653">std::<span class="me2">memory_order_relaxed</span></span></a><span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1055">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><a href="../thread/thread.html"><span class="kw1662">std::<span class="me2">thread</span></span></a><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> n <span class="sy1">&lt;</span> <span class="nu0">10</span><span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">)</span> <span class="br0">{</span>
        v.<span class="me1">emplace_back</span><span class="br0">(</span>f<span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw4">auto</span><span class="sy3">&amp;</span> t <span class="sy4">:</span> v<span class="br0">)</span> <span class="br0">{</span>
        t.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
    <a href="../io/basic_ostream.html"><span class="kw1418">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"Final counter value is "</span> <span class="sy1">&lt;&lt;</span> cnt <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">Final counter value is 10000</pre></div></div>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=10" title="Edit section: std::memory order release and memory order acquire">edit</a>]</span> <span class="mw-headline" id="std::memory_order_release_and_memory_order_acquire">std::memory_order_release and memory_order_acquire</span>
</h4>
<p> Mutexes, concurrent queues, and other producer-consumer situations require release ordering in the publisher thread and acquire ordering in the consumer thread. This pattern establishes pairwise synchronization between threads.
 </p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
 
<a href="atomic.html"><span class="kw1626">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="sy2">*</span><span class="sy1">&gt;</span> ptr<span class="sy4">;</span>
<span class="kw4">int</span> data<span class="sy4">;</span>
 
<span class="kw4">void</span> producer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p  <span class="sy1">=</span> new <a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="br0">(</span><span class="st0">"Hello"</span><span class="br0">)</span><span class="sy4">;</span>
    data <span class="sy1">=</span> <span class="nu0">42</span><span class="sy4">;</span>
    ptr.<span class="me1">store</span><span class="br0">(</span>p, <a href="memory_order.html"><span class="kw1656">std::<span class="me2">memory_order_release</span></span></a><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> consumer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p2<span class="sy4">;</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span><span class="br0">(</span>p2 <span class="sy1">=</span> ptr.<span class="me1">load</span><span class="br0">(</span><a href="memory_order.html"><span class="kw1655">std::<span class="me2">memory_order_acquire</span></span></a><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span><span class="sy2">*</span>p2 <span class="sy1">==</span> <span class="st0">"Hello"</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// never fires</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span>data <span class="sy1">==</span> <span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// never fires</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw1662">std::<span class="me2">thread</span></span></a> t1<span class="br0">(</span>producer<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1662">std::<span class="me2">thread</span></span></a> t2<span class="br0">(</span>consumer<span class="br0">)</span><span class="sy4">;</span>
    t1.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> t2.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br></p>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=11" title="Edit section: std::memory order ack rel">edit</a>]</span> <span class="mw-headline" id="std::memory_order_ack_rel">std::memory_order_ack_rel</span>
</h4>
<p> The follow example demonstrates transitive release-acquire ordering across three threads
 </p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
<span class="co2">#include &lt;vector&gt;</span>
 
<a href="../container/vector.html"><span class="kw1055">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> data<span class="sy4">;</span>
<a href="atomic.html"><span class="kw1626">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> flag <span class="sy1">=</span> <a href="ATOMIC_VAR_INIT.html"><span class="kw1650">ATOMIC_VAR_INIT</span></a><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
 
<span class="kw4">void</span> thread_1<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    data.<span class="me1">push_back</span><span class="br0">(</span><span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span>
    flag.<span class="me1">store</span><span class="br0">(</span><span class="nu0">1</span>, <a href="memory_order.html"><span class="kw1656">std::<span class="me2">memory_order_release</span></span></a><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> thread_2<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> expected<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>flag.<span class="me1">compare_exchange_strong</span><span class="br0">(</span>expected, <span class="nu0">2</span>, <a href="memory_order.html"><span class="kw1657">std::<span class="me2">memory_order_acq_rel</span></span></a><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        expected <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> thread_3<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">while</span> <span class="br0">(</span>flag.<span class="me1">load</span><span class="br0">(</span><a href="memory_order.html"><span class="kw1655">std::<span class="me2">memory_order_acquire</span></span></a><span class="br0">)</span> <span class="sy1">&lt;</span> <span class="nu0">2</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span>data.<span class="me1">at</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span> <span class="sy1">==</span> <span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// will never fire</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw1662">std::<span class="me2">thread</span></span></a> a<span class="br0">(</span>thread_1<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1662">std::<span class="me2">thread</span></span></a> b<span class="br0">(</span>thread_2<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1662">std::<span class="me2">thread</span></span></a> c<span class="br0">(</span>thread_3<span class="br0">)</span><span class="sy4">;</span>
    a.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> b.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> c.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<h4>
<span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=12" title="Edit section: std::memory order release and std::memory order consume">edit</a>]</span> <span class="mw-headline" id="std::memory_order_release_and_std::memory_order_consume">std::memory_order_release and std::memory_order_consume</span>
</h4>
<p> This example demonstrates dependency-ordered synchronization: the integer data is not related to the pointer to string by a data-dependency relationship, thus its value is undefined in the consumer.
 </p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
 
<a href="atomic.html"><span class="kw1626">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="sy2">*</span><span class="sy1">&gt;</span> ptr<span class="sy4">;</span>
<span class="kw4">int</span> data<span class="sy4">;</span>
 
<span class="kw4">void</span> producer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p  <span class="sy1">=</span> new <a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="br0">(</span><span class="st0">"Hello"</span><span class="br0">)</span><span class="sy4">;</span>
    data <span class="sy1">=</span> <span class="nu0">42</span><span class="sy4">;</span>
    ptr.<span class="me1">store</span><span class="br0">(</span>p, <a href="memory_order.html"><span class="kw1656">std::<span class="me2">memory_order_release</span></span></a><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> consumer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1034">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p2<span class="sy4">;</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span><span class="br0">(</span>p2 <span class="sy1">=</span> ptr.<span class="me1">load</span><span class="br0">(</span><a href="memory_order.html"><span class="kw1654">std::<span class="me2">memory_order_consume</span></span></a><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span><span class="sy2">*</span>p2 <span class="sy1">==</span> <span class="st0">"Hello"</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// never fires</span>
    <a href="../error/assert.html"><span class="kw619">assert</span></a><span class="br0">(</span>data <span class="sy1">==</span> <span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// may or may not fire</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw1662">std::<span class="me2">thread</span></span></a> t1<span class="br0">(</span>producer<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw1662">std::<span class="me2">thread</span></span></a> t2<span class="br0">(</span>consumer<span class="br0">)</span><span class="sy4">;</span>
    t1.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> t2.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>

<!-- 
NewPP limit report
Preprocessor node count: 1937/1000000
Post-expand include size: 56677/2097152 bytes
Template argument size: 37211/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:2839-0!*!0!!en!*!* and timestamp 20120615223637 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;oldid=33527">http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;oldid=33527</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks catlinks-allhidden"></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script src="../../../common/loadac2a.php?debug=false&amp;lang=en&amp;modules=skins.cppreference2&amp;only=scripts&amp;skin=cppreference2&amp;*"></script><script>if(window.mw){
	mw.loader.load(["mediawiki.user", "mediawiki.util", "mediawiki.page.ready", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax"]);
}
</script><script src="../../../common/load345b.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=cppreference2&amp;*"></script><script>if(window.mw){
	mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0
	,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mw.user.tokens.set({"editToken":"+\\","watchToken":false});;mw.loader.state({"user.options":"ready","user.tokens":"ready"});
	
	/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-js:4:3740695a1552aee37d594967bd36f869 */
}
</script><script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2828341-1");
pageTracker._trackPageview();
</script><!-- Served in 3.037 secs. -->
</body>
<!-- Cached 20120615223647 -->
</html>
